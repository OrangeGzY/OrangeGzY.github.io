<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统相关概念整理与复习 | ScUpax0s</title><meta name="description" content="选择题+名词解释+简答题+计算题  期末复习，基于《操作系统——精髓与设计原理》的总结  [TOC] 第一章——计算机系统概述选cpu状态（用户系统）CPU的工作状态分为系统态(或称管理态，管态，内核态)和用户态(或称目态)。引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为，当CPU处于用户态时，不允许执行特权指令；当CPU处于系统态时，可执"><meta name="author" content="Paxos"><meta name="copyright" content="Paxos"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="操作系统相关概念整理与复习"><meta name="twitter:description" content="选择题+名词解释+简答题+计算题  期末复习，基于《操作系统——精髓与设计原理》的总结  [TOC] 第一章——计算机系统概述选cpu状态（用户系统）CPU的工作状态分为系统态(或称管理态，管态，内核态)和用户态(或称目态)。引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为，当CPU处于用户态时，不允许执行特权指令；当CPU处于系统态时，可执"><meta name="twitter:image" content="https://s1.ax1x.com/2020/06/26/NDRFPJ.png"><meta property="og:type" content="article"><meta property="og:title" content="操作系统相关概念整理与复习"><meta property="og:url" content="http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/"><meta property="og:site_name" content="ScUpax0s"><meta property="og:description" content="选择题+名词解释+简答题+计算题  期末复习，基于《操作系统——精髓与设计原理》的总结  [TOC] 第一章——计算机系统概述选cpu状态（用户系统）CPU的工作状态分为系统态(或称管理态，管态，内核态)和用户态(或称目态)。引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为，当CPU处于用户态时，不允许执行特权指令；当CPU处于系统态时，可执"><meta property="og:image" content="https://s1.ax1x.com/2020/06/26/NDRFPJ.png"><meta property="article:published_time" content="2020-06-25T18:02:56.000Z"><meta property="article:modified_time" content="2020-06-25T18:05:25.214Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/"><link rel="prev" title="linux 内核pwn (0)" href="http://yoursite.com/2020/07/12/linux-%E5%86%85%E6%A0%B8pwn-0/"><link rel="next" title="BUUoj-rctf2018_babyheap-off-by-null" href="http://yoursite.com/2020/06/21/BUUoj-rctf2018-babyheap-off-by-null/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/15/N9ZTBV.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章——计算机系统概述"><span class="toc-number">1.</span> <span class="toc-text">第一章——计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选"><span class="toc-number">1.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu状态（用户系统）"><span class="toc-number">1.1.1.</span> <span class="toc-text">cpu状态（用户系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断产生的背景"><span class="toc-number">1.1.2.</span> <span class="toc-text">中断产生的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断的处理流程"><span class="toc-number">1.1.3.</span> <span class="toc-text">中断的处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断现场的保护和恢复"><span class="toc-number">1.1.4.</span> <span class="toc-text">中断现场的保护和恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名"><span class="toc-number">1.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指令周期（是否有中断两种情况）"><span class="toc-number">1.2.1.</span> <span class="toc-text">指令周期（是否有中断两种情况）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#储存层次结构"><span class="toc-number">1.2.2.</span> <span class="toc-text">储存层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部性"><span class="toc-number">1.2.3.</span> <span class="toc-text">局部性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO三种方法"><span class="toc-number">1.2.4.</span> <span class="toc-text">IO三种方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章——操作系统概述"><span class="toc-number">2.</span> <span class="toc-text">第二章——操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-1"><span class="toc-number">2.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多道的中断"><span class="toc-number">2.1.1.</span> <span class="toc-text">多道的中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时"><span class="toc-number">2.1.2.</span> <span class="toc-text">os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os与一般程序的区别：P33"><span class="toc-number">2.1.3.</span> <span class="toc-text">os与一般程序的区别：P33</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-1"><span class="toc-number">2.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os的概念：P31"><span class="toc-number">2.2.1.</span> <span class="toc-text">os的概念：P31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分时系统：P38"><span class="toc-number">2.2.2.</span> <span class="toc-text">分时系统：P38</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批处理系统：P34-P36"><span class="toc-number">2.2.3.</span> <span class="toc-text">批处理系统：P34-P36</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多道：P36"><span class="toc-number">2.2.4.</span> <span class="toc-text">多道：P36</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简"><span class="toc-number">2.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os功能：P32"><span class="toc-number">2.3.1.</span> <span class="toc-text">os功能：P32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分时与批处理系统产生的类型（为什么引入？）-P34-36"><span class="toc-number">2.3.2.</span> <span class="toc-text">分时与批处理系统产生的类型（为什么引入？）:P34-36.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os的目标（3个）：P31"><span class="toc-number">2.3.3.</span> <span class="toc-text">os的目标（3个）：P31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分时系统和批处理系统的异同（有一张表"><span class="toc-number">2.3.4.</span> <span class="toc-text">分时系统和批处理系统的异同（有一张表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章——进程"><span class="toc-number">3.</span> <span class="toc-text">第三章——进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-2"><span class="toc-number">3.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os为了实现进程-并发-需要cpu哪些硬件支持（为什么需要？）"><span class="toc-number">3.1.1.</span> <span class="toc-text">os为了实现进程&#x2F;并发 需要cpu哪些硬件支持（为什么需要？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和程序之间的差异？（从结构上）进程包含上下文-指令序列-代码、程序只是一个概念没有上下文。"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程和程序之间的差异？（从结构上）进程包含上下文&#x2F;指令序列&#x2F;代码、程序只是一个概念没有上下文。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的生命周期（从创建到结束、7状态图）"><span class="toc-number">3.1.3.</span> <span class="toc-text">进程的生命周期（从创建到结束、7状态图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞函数的含义"><span class="toc-number">3.1.4.</span> <span class="toc-text">阻塞函数的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-2"><span class="toc-number">3.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么叫进程？（答出进程的组成）"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么叫进程？（答出进程的组成）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是PCB"><span class="toc-number">3.2.2.</span> <span class="toc-text">什么是PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU的模式"><span class="toc-number">3.2.3.</span> <span class="toc-text">CPU的模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是进程的状态以及引入的原因"><span class="toc-number">3.2.4.</span> <span class="toc-text">什么是进程的状态以及引入的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-1"><span class="toc-number">3.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB的构成"><span class="toc-number">3.3.1.</span> <span class="toc-text">PCB的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五状态图和七状态图：P76-P79"><span class="toc-number">3.3.2.</span> <span class="toc-text">五状态图和七状态图：P76 P79</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五状态图和七状态图中的状态变化-变化的流程"><span class="toc-number">3.3.3.</span> <span class="toc-text">五状态图和七状态图中的状态变化(变化的流程)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89"><span class="toc-number">3.3.4.</span> <span class="toc-text">进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程创建的流程（分配pid到分配内存…）P74"><span class="toc-number">3.3.5.</span> <span class="toc-text">进程创建的流程（分配pid到分配内存…）P74</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程切换的时机（4种？）P88"><span class="toc-number">3.3.6.</span> <span class="toc-text">进程切换的时机（4种？）P88</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章——线程SMP微内核的"><span class="toc-number">4.</span> <span class="toc-text">第四章——线程SMP微内核的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-3"><span class="toc-number">4.1.</span> <span class="toc-text">选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-3"><span class="toc-number">4.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么叫做线程？-（一个独立的指令的执行序列）"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么叫做线程？    （一个独立的指令的执行序列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）"><span class="toc-number">4.2.2.</span> <span class="toc-text">有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是SMP-（概念、形式（耦合））"><span class="toc-number">4.2.3.</span> <span class="toc-text">什么是SMP     （概念、形式（耦合））</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#微内核概念-（只将重要的部分作为内核实现，剩下的程序实现）"><span class="toc-number">4.2.4.</span> <span class="toc-text">微内核概念    （只将重要的部分作为内核实现，剩下的程序实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏内核概念-（把os所有功能放入内核）"><span class="toc-number">4.2.5.</span> <span class="toc-text">宏内核概念    （把os所有功能放入内核）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-2"><span class="toc-number">4.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程与线程的关系-（从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））"><span class="toc-number">4.3.1.</span> <span class="toc-text">进程与线程的关系  （从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现线程方法-（用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user-mode与kernel-mode的优点））P103"><span class="toc-number">4.3.2.</span> <span class="toc-text">实现线程方法  （用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user mode与kernel mode的优点））P103</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态进程的优缺点-和-内核态进程的优缺点P104"><span class="toc-number">4.3.3.</span> <span class="toc-text">用户态进程的优缺点 和 内核态进程的优缺点P104</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用微内核的好处-（优点：，缺陷：增加了模式切换的次数。以及改进方法：1-更好的设计。2-）"><span class="toc-number">4.3.4.</span> <span class="toc-text">使用微内核的好处  （优点：，缺陷：增加了模式切换的次数。以及改进方法：1.更好的设计。2.）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章——同步和互斥（最难）"><span class="toc-number">5.</span> <span class="toc-text">第五章——同步和互斥（最难）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-4"><span class="toc-number">5.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）"><span class="toc-number">5.1.1.</span> <span class="toc-text">并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1-中断屏蔽但多核失效。2-硬件指令：原子操作概念。3-编译器）P136"><span class="toc-number">5.1.2.</span> <span class="toc-text">互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1.中断屏蔽但多核失效。2.硬件指令：原子操作概念。3.编译器）P136</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-4"><span class="toc-number">5.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并行与并发的概念"><span class="toc-number">5.2.1.</span> <span class="toc-text">并行与并发的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥的概念"><span class="toc-number">5.2.2.</span> <span class="toc-text">互斥的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlap（覆盖技术）"><span class="toc-number">5.2.3.</span> <span class="toc-text">overlap（覆盖技术）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步"><span class="toc-number">5.2.4.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区：Cirtical-section"><span class="toc-number">5.2.5.</span> <span class="toc-text">临界区：Cirtical section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#race-condition（条件竞争）P132"><span class="toc-number">5.2.6.</span> <span class="toc-text">race condition（条件竞争）P132</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作"><span class="toc-number">5.2.7.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">5.2.8.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#……-（有张表上所有概念都要掌握）"><span class="toc-number">5.2.9.</span> <span class="toc-text">…….（有张表上所有概念都要掌握）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-3"><span class="toc-number">5.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发中解决的四个问题-P130"><span class="toc-number">5.3.1.</span> <span class="toc-text">并发中解决的四个问题 P130</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量的类型（一般互斥计数强弱）"><span class="toc-number">5.3.2.</span> <span class="toc-text">信号量的类型（一般互斥计数强弱）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现互斥的三种方法（信号量、管程……）"><span class="toc-number">5.3.3.</span> <span class="toc-text">实现互斥的三种方法（信号量、管程……）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件上如何实现互斥同步（swap、test）"><span class="toc-number">5.3.4.</span> <span class="toc-text">硬件上如何实现互斥同步（swap、test）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计"><span class="toc-number">5.4.</span> <span class="toc-text">计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者消费者、读者写者问题"><span class="toc-number">5.4.1.</span> <span class="toc-text">生产者消费者、读者写者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章——并发：死锁和饥饿"><span class="toc-number">6.</span> <span class="toc-text">第六章——并发：死锁和饥饿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-5"><span class="toc-number">6.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁与饥饿（资源向量、可用资源向量等）"><span class="toc-number">6.1.1.</span> <span class="toc-text">死锁与饥饿（资源向量、可用资源向量等）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁活锁饥饿"><span class="toc-number">6.1.2.</span> <span class="toc-text">死锁活锁饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-4"><span class="toc-number">6.2.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的必要条件x3"><span class="toc-number">6.2.1.</span> <span class="toc-text">死锁的必要条件x3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的充要条件x4"><span class="toc-number">6.2.2.</span> <span class="toc-text">死锁的充要条件x4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决死锁的方法（3-or-4大类：死锁预防、避免、检测、消除、鸵鸟）P177"><span class="toc-number">6.2.3.</span> <span class="toc-text">解决死锁的方法（3 or 4大类：死锁预防、避免、检测、消除、鸵鸟）P177</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁与饥饿的关系"><span class="toc-number">6.2.4.</span> <span class="toc-text">死锁与饥饿的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计-1"><span class="toc-number">6.3.</span> <span class="toc-text">计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#银行家算法（算新的请求能不能分配）"><span class="toc-number">6.3.1.</span> <span class="toc-text">银行家算法（算新的请求能不能分配）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）"><span class="toc-number">6.3.2.</span> <span class="toc-text">死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哲学家就餐"><span class="toc-number">6.3.3.</span> <span class="toc-text">哲学家就餐</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章——内存管理"><span class="toc-number">7.</span> <span class="toc-text">第七章——内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-6"><span class="toc-number">7.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#段表和页表（构造、结构、如何-什么时候使用）"><span class="toc-number">7.1.1.</span> <span class="toc-text">段表和页表（构造、结构、如何&#x2F;什么时候使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-5"><span class="toc-number">7.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重定位-P205"><span class="toc-number">7.2.1.</span> <span class="toc-text">重定位 P205</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#覆盖overlaying"><span class="toc-number">7.2.2.</span> <span class="toc-text">覆盖overlaying</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑、物理、相对地址-P212"><span class="toc-number">7.2.3.</span> <span class="toc-text">逻辑、物理、相对地址 P212</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交换"><span class="toc-number">7.2.4.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#碎片（内部与外部）"><span class="toc-number">7.2.5.</span> <span class="toc-text">碎片（内部与外部）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伙伴系统"><span class="toc-number">7.2.6.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-5"><span class="toc-number">7.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理几种方法与联系差异（分段与固定分区等）P206"><span class="toc-number">7.3.1.</span> <span class="toc-text">内存管理几种方法与联系差异（分段与固定分区等）P206-</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#首次适应、最佳匹配、最坏匹配等-P209"><span class="toc-number">7.3.2.</span> <span class="toc-text">首次适应、最佳匹配、最坏匹配等 P209</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伙伴系统内存分配与回收"><span class="toc-number">7.3.3.</span> <span class="toc-text">伙伴系统内存分配与回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单分段与分页的要点（逻辑地址到物理地址转换：1-2-3-4-）"><span class="toc-number">7.3.4.</span> <span class="toc-text">简单分段与分页的要点（逻辑地址到物理地址转换：1.2.3.4.）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章——虚拟存储"><span class="toc-number">8.</span> <span class="toc-text">第八章——虚拟存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-7"><span class="toc-number">8.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。"><span class="toc-number">8.1.1.</span> <span class="toc-text">七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解虚拟存储器-P224"><span class="toc-number">8.1.2.</span> <span class="toc-text">如何理解虚拟存储器 P224</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引入虚拟存储器后地址空间是什么样子-P226-227"><span class="toc-number">8.1.3.</span> <span class="toc-text">引入虚拟存储器后地址空间是什么样子 P226-227</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保护和共享（段、页表）P223"><span class="toc-number">8.1.4.</span> <span class="toc-text">保护和共享（段、页表）P223</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现虚拟存储器需要哪些硬件支持"><span class="toc-number">8.1.5.</span> <span class="toc-text">实现虚拟存储器需要哪些硬件支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-6"><span class="toc-number">8.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#page-fault"><span class="toc-number">8.2.1.</span> <span class="toc-text">page fault</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抖动"><span class="toc-number">8.2.2.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向页表"><span class="toc-number">8.2.3.</span> <span class="toc-text">反向页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB，转换检测缓冲区）"><span class="toc-number">8.2.4.</span> <span class="toc-text">TLB，转换检测缓冲区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页缓冲-P244"><span class="toc-number">8.2.5.</span> <span class="toc-text">页缓冲 P244</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟存储器中的一些策略：加载、清楚-etc-P243-244"><span class="toc-number">8.2.6.</span> <span class="toc-text">虚拟存储器中的一些策略：加载、清楚 etc. P243-244</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚存的空间分配"><span class="toc-number">8.2.7.</span> <span class="toc-text">虚存的空间分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简答"><span class="toc-number">8.3.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚存实现方法（请求分页分段以及）"><span class="toc-number">8.3.1.</span> <span class="toc-text">虚存实现方法（请求分页分段以及）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺页中断处理流程"><span class="toc-number">8.3.2.</span> <span class="toc-text">缺页中断处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页分段地址翻译过程"><span class="toc-number">8.3.3.</span> <span class="toc-text">分页分段地址翻译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚存中段、页表数据结构"><span class="toc-number">8.3.4.</span> <span class="toc-text">虚存中段、页表数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级页表的原因以及优缺点"><span class="toc-number">8.3.5.</span> <span class="toc-text">多级页表的原因以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驻留集中的几个变化-P224"><span class="toc-number">8.3.6.</span> <span class="toc-text">驻留集中的几个变化 P224</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计-2"><span class="toc-number">8.4.</span> <span class="toc-text">计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断-P236"><span class="toc-number">8.4.1.</span> <span class="toc-text">页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断 P236</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章——单处理器调度"><span class="toc-number">9.</span> <span class="toc-text">第九章——单处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-8"><span class="toc-number">9.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程调度切换抢占等"><span class="toc-number">9.1.1.</span> <span class="toc-text">进程调度切换抢占等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-7"><span class="toc-number">9.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#长、中、短程调度"><span class="toc-number">9.2.1.</span> <span class="toc-text">长、中、短程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占"><span class="toc-number">9.2.2.</span> <span class="toc-text">抢占</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-6"><span class="toc-number">9.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#长、中、短程调度含义以及状态图变化有哪些"><span class="toc-number">9.3.1.</span> <span class="toc-text">长、中、短程调度含义以及状态图变化有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种调度类型的一些概念：比如到达时间等"><span class="toc-number">9.3.2.</span> <span class="toc-text">三种调度类型的一些概念：比如到达时间等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计-3"><span class="toc-number">9.4.</span> <span class="toc-text">计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程调度算法-P262"><span class="toc-number">9.4.1.</span> <span class="toc-text">进程调度算法 P262</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另"><span class="toc-number">9.5.</span> <span class="toc-text">另</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第11章——IO"><span class="toc-number">10.</span> <span class="toc-text">第11章——IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-9"><span class="toc-number">10.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO模块的功能-P312"><span class="toc-number">10.1.1.</span> <span class="toc-text">IO模块的功能 P312</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO模块的层次设计（三张图）"><span class="toc-number">10.1.2.</span> <span class="toc-text">IO模块的层次设计（三张图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-8"><span class="toc-number">10.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是块设备-P315"><span class="toc-number">10.2.1.</span> <span class="toc-text">什么是块设备 P315</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是流设备"><span class="toc-number">10.2.2.</span> <span class="toc-text">什么是流设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-7"><span class="toc-number">10.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入IO缓冲原因"><span class="toc-number">10.3.1.</span> <span class="toc-text">引入IO缓冲原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO缓冲三种方式-P316"><span class="toc-number">10.3.2.</span> <span class="toc-text">IO缓冲三种方式 P316</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘调度中的延迟（5个）P318"><span class="toc-number">10.3.3.</span> <span class="toc-text">磁盘调度中的延迟（5个）P318</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计-4"><span class="toc-number">10.4.</span> <span class="toc-text">计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘调度算法"><span class="toc-number">10.4.1.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第12章——文件管理"><span class="toc-number">11.</span> <span class="toc-text">第12章——文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选-10"><span class="toc-number">11.1.</span> <span class="toc-text">选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要文件系统"><span class="toc-number">11.1.1.</span> <span class="toc-text">为什么需要文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统目标-P342"><span class="toc-number">11.1.2.</span> <span class="toc-text">文件系统目标 P342</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统架构-P343"><span class="toc-number">11.1.3.</span> <span class="toc-text">文件系统架构 P343</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名-9"><span class="toc-number">11.2.</span> <span class="toc-text">名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是文件-P340"><span class="toc-number">11.2.1.</span> <span class="toc-text">什么是文件 P340</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统概念-P340"><span class="toc-number">11.2.2.</span> <span class="toc-text">文件系统概念 P340</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件管理系统的概念-P342"><span class="toc-number">11.2.3.</span> <span class="toc-text">文件管理系统的概念 P342</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统层次结构-P343"><span class="toc-number">11.2.4.</span> <span class="toc-text">文件系统层次结构 P343</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件分配表、相对与绝对路径"><span class="toc-number">11.2.5.</span> <span class="toc-text">文件分配表、相对与绝对路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简-8"><span class="toc-number">11.3.</span> <span class="toc-text">简</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件组织形式（堆、顺序等5种）P345-346"><span class="toc-number">11.3.1.</span> <span class="toc-text">文件组织形式（堆、顺序等5种）P345-346</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理层次上文件的结构（外存上面）"><span class="toc-number">11.3.2.</span> <span class="toc-text">物理层次上文件的结构（外存上面）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录的实现方式"><span class="toc-number">11.3.3.</span> <span class="toc-text">目录的实现方式</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://s1.ax1x.com/2020/06/26/NDRFPJ.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ScUpax0s</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">操作系统相关概念整理与复习</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-06-26 02:02:56"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-06-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-06-26 02:05:25"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-26</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><span class="disqus-comment-count comment-count"><a href="http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/#disqus_thread"></a></span></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>选择题+名词解释+简答题+计算题</p>
<hr>
<p><strong>期末复习，基于《操作系统——精髓与设计原理》的总结</strong></p>
<hr>
<p>[TOC]</p>
<h1 id="第一章——计算机系统概述"><a href="#第一章——计算机系统概述" class="headerlink" title="第一章——计算机系统概述"></a>第一章——计算机系统概述</h1><h2 id="选"><a href="#选" class="headerlink" title="选"></a>选</h2><h3 id="cpu状态（用户系统）"><a href="#cpu状态（用户系统）" class="headerlink" title="cpu状态（用户系统）"></a>cpu状态（用户系统）</h3><p>CPU的工作状态分为系统态(或称管理态，管态，内核态)和用户态(或称目态)。<br>引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为，当CPU处于用户态时，不允许执行特权指令；当CPU处于系统态时，可执行包括特权指令在内的一切机器指令。<br>主要切换方式：系统调用、异常、外围设备的中断。</p>
<h3 id="中断产生的背景"><a href="#中断产生的背景" class="headerlink" title="中断产生的背景"></a>中断产生的背景</h3><p>用于提高处理器的效率的一种手段。例如：多数的IO设备都要远慢于处理器。引入中断可提高处理器相关的效率。</p>
<h3 id="中断的处理流程"><a href="#中断的处理流程" class="headerlink" title="中断的处理流程"></a>中断的处理流程</h3><p><img src="https://s1.ax1x.com/2020/06/23/NN867n.png" alt=""></p>
<h3 id="中断现场的保护和恢复"><a href="#中断现场的保护和恢复" class="headerlink" title="中断现场的保护和恢复"></a>中断现场的保护和恢复</h3><p>1.中断发生时，需要保存中断点时程序的PSW和PC中下一条要执行的指令地址、以及一些寄存器等其他信息。他们被push进系统<a href="http://blog.chinaunix.net/uid-23860671-id-2974457.html" target="_blank" rel="noopener">系统栈</a><br>2.然后栈指针更新，指向新的栈顶；pc更新，指向中断服务程序的开始。<br>3.中断结束后从系统栈中恢复寄存器以及psw和pc的信息。继续执行。</p>
<h2 id="名"><a href="#名" class="headerlink" title="名"></a>名</h2><h3 id="指令周期（是否有中断两种情况）"><a href="#指令周期（是否有中断两种情况）" class="headerlink" title="指令周期（是否有中断两种情况）"></a>指令周期（是否有中断两种情况）</h3><p>单个指令所需要的处理成为一个指令周期。<br>1.无中断时：P8<br>2.有中断时：P12，就是要加一个中断阶段，处理器检查是否有中断信号</p>
<h3 id="储存层次结构"><a href="#储存层次结构" class="headerlink" title="储存层次结构"></a>储存层次结构</h3><p>存储层次是在计算机体系结构下存储系统层次结构的排列顺序。<br>对于通用计算机而言，存储层次分为四层：CPU寄存器。高速缓存、主存和辅存。对于CPU 寄存器，CPU 可以再一个时钟周期内访问它们。接下来是一个或者多个小型到中型的基于 SRAM 的高速缓存存储器，可以再几个 CPU 时钟周期内访问它们。然后是一个大的基于 DRAM 的主存，可以在几十或者几百个时钟周期内访问它们。接下来是慢速但是容量很大的本地磁盘。存储器层次结构的核心是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。也就是说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出文件的缓存，以此类推知道 CPU 寄存器。</p>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>1.时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。（典型的程序包括许多迭代循环和子程序）<br>2.空间局部性（Spatial Locality）：在最近的将来将用到的信息很可能与正在使用的信息在空间地址上是临近的。<br>3.顺序局部性（Order Locality）：在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型数组访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。</p>
<h3 id="IO三种方法"><a href="#IO三种方法" class="headerlink" title="IO三种方法"></a>IO三种方法</h3><p>1.可编程IO:处理器不断询问IO模块状态<br>2.中断驱动IO：IO模块处理，处理结束后向处理器发送中断<br>3.直接内存存取（DMA）：系统总线中独立的模块也可以并入IO模块中。不需要处理器参与。结束后给处理器发中断。但可能跟处理器抢总线。P21</p>
<h1 id="第二章——操作系统概述"><a href="#第二章——操作系统概述" class="headerlink" title="第二章——操作系统概述"></a>第二章——操作系统概述</h1><h2 id="选-1"><a href="#选-1" class="headerlink" title="选"></a>选</h2><h3 id="多道的中断"><a href="#多道的中断" class="headerlink" title="多道的中断"></a>多道的中断</h3><h3 id="os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时"><a href="#os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时" class="headerlink" title="os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时"></a>os类型：串行、简单批处理（引入监控程序）、多道批处理（提升效率）、分时</h3><h3 id="os与一般程序的区别：P33"><a href="#os与一般程序的区别：P33" class="headerlink" title="os与一般程序的区别：P33"></a>os与一般程序的区别：P33</h3><h2 id="名-1"><a href="#名-1" class="headerlink" title="名"></a>名</h2><h3 id="os的概念：P31"><a href="#os的概念：P31" class="headerlink" title="os的概念：P31"></a>os的概念：P31</h3><h3 id="分时系统：P38"><a href="#分时系统：P38" class="headerlink" title="分时系统：P38"></a>分时系统：P38</h3><h3 id="批处理系统：P34-P36"><a href="#批处理系统：P34-P36" class="headerlink" title="批处理系统：P34-P36"></a>批处理系统：P34-P36</h3><h3 id="多道：P36"><a href="#多道：P36" class="headerlink" title="多道：P36"></a>多道：P36</h3><h2 id="简"><a href="#简" class="headerlink" title="简"></a>简</h2><h3 id="os功能：P32"><a href="#os功能：P32" class="headerlink" title="os功能：P32"></a>os功能：P32</h3><p>程序开发、程序运行、IO设备、文件访问控制、系统访问、错误检测和响应、记账等</p>
<h3 id="分时与批处理系统产生的类型（为什么引入？）-P34-36"><a href="#分时与批处理系统产生的类型（为什么引入？）-P34-36" class="headerlink" title="分时与批处理系统产生的类型（为什么引入？）:P34-36."></a>分时与批处理系统产生的类型（为什么引入？）:P34-36.</h3><p>1.引入简单批处理：最大限度使用处理器。引入监控程序（类似于现在的内核）<br>2.多道批处理：简单批处理系统中，处理器常常处于空闲状态，IO设备相对于处理器太慢了。多道可以实现作业任务的切换（作业间没有资源竞争），提升使用效率。<br>3.分时系统：引入用户与计算机直接交互的模式，多个用户共享处理器时间，os控制每个用户程序在很短时间内交替执行。（时间片time slicing）</p>
<h3 id="os的目标（3个）：P31"><a href="#os的目标（3个）：P31" class="headerlink" title="os的目标（3个）：P31"></a>os的目标（3个）：P31</h3><p>1.方便：让计算机更加利于使用<br>2.有效：以更有效的方式使用计算机的资源<br>3.扩展能力：在不妨碍服务的前提下，有效的开发测试和引入新的系统功能。</p>
<h3 id="分时系统和批处理系统的异同（有一张表"><a href="#分时系统和批处理系统的异同（有一张表" class="headerlink" title="分时系统和批处理系统的异同（有一张表"></a>分时系统和批处理系统的异同（有一张表</h3><p><img src="https://s1.ax1x.com/2020/06/23/NUQbge.png" alt=""></p>
<h1 id="第三章——进程"><a href="#第三章——进程" class="headerlink" title="第三章——进程"></a>第三章——进程</h1><h2 id="选-2"><a href="#选-2" class="headerlink" title="选"></a>选</h2><h3 id="os为了实现进程-并发-需要cpu哪些硬件支持（为什么需要？）"><a href="#os为了实现进程-并发-需要cpu哪些硬件支持（为什么需要？）" class="headerlink" title="os为了实现进程/并发 需要cpu哪些硬件支持（为什么需要？）"></a>os为了实现进程/并发 需要cpu哪些硬件支持（为什么需要？）</h3><h3 id="进程和程序之间的差异？（从结构上）进程包含上下文-指令序列-代码、程序只是一个概念没有上下文。"><a href="#进程和程序之间的差异？（从结构上）进程包含上下文-指令序列-代码、程序只是一个概念没有上下文。" class="headerlink" title="进程和程序之间的差异？（从结构上）进程包含上下文/指令序列/代码、程序只是一个概念没有上下文。"></a>进程和程序之间的差异？（从结构上）进程包含上下文/指令序列/代码、程序只是一个概念没有上下文。</h3><h3 id="进程的生命周期（从创建到结束、7状态图）"><a href="#进程的生命周期（从创建到结束、7状态图）" class="headerlink" title="进程的生命周期（从创建到结束、7状态图）"></a>进程的生命周期（从创建到结束、7状态图）</h3><h3 id="阻塞函数的含义"><a href="#阻塞函数的含义" class="headerlink" title="阻塞函数的含义"></a>阻塞函数的含义</h3><p>阻塞调用是指调用结果返回之前,当前线程会被挂起。函数只有在得到结果之后才会返回。</p>
<h2 id="名-2"><a href="#名-2" class="headerlink" title="名"></a>名</h2><h3 id="什么叫进程？（答出进程的组成）"><a href="#什么叫进程？（答出进程的组成）" class="headerlink" title="什么叫进程？（答出进程的组成）"></a>什么叫进程？（答出进程的组成）</h3><p>一个正在计算机上执行的程序的实例。<br>组成 P71:标识符、状态、优先级、PC、内存指针、上下文数据、IO状态信息、记账信息（accounting）储存在PCB中</p>
<h3 id="什么是PCB"><a href="#什么是PCB" class="headerlink" title="什么是PCB"></a>什么是PCB</h3><p>进程控制块，储存了进程的一系列信息，由操作系统创建和管理</p>
<h3 id="CPU的模式"><a href="#CPU的模式" class="headerlink" title="CPU的模式"></a>CPU的模式</h3><h3 id="什么是进程的状态以及引入的原因"><a href="#什么是进程的状态以及引入的原因" class="headerlink" title="什么是进程的状态以及引入的原因"></a>什么是进程的状态以及引入的原因</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。<br>引入原因：更好的实现进程的调度，控制进程的执行，包括确定交替执行的方式和给进程分配资源。</p>
<h2 id="简-1"><a href="#简-1" class="headerlink" title="简"></a>简</h2><h3 id="PCB的构成"><a href="#PCB的构成" class="headerlink" title="PCB的构成"></a>PCB的构成</h3><p>标识符、状态、优先级、PC、内存指针、上下文数据、IO状态信息、记账信息（accounting）储存在PCB中</p>
<h3 id="五状态图和七状态图：P76-P79"><a href="#五状态图和七状态图：P76-P79" class="headerlink" title="五状态图和七状态图：P76 P79"></a>五状态图和七状态图：P76 P79</h3><h3 id="五状态图和七状态图中的状态变化-变化的流程"><a href="#五状态图和七状态图中的状态变化-变化的流程" class="headerlink" title="五状态图和七状态图中的状态变化(变化的流程)"></a>五状态图和七状态图中的状态变化(变化的流程)</h3><h3 id="进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89"><a href="#进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89" class="headerlink" title="进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89"></a>进程切换和模式切换的差异（概念、差异是什么：进程切换包含模式切换，代价更高，还要保存进程上下文……）P88-89</h3><h3 id="进程创建的流程（分配pid到分配内存…）P74"><a href="#进程创建的流程（分配pid到分配内存…）P74" class="headerlink" title="进程创建的流程（分配pid到分配内存…）P74"></a>进程创建的流程（分配pid到分配内存…）P74</h3><p>（1）申请空白的PCB。<br>（2）为新进程分配资源。<br>（3）初始化PCB。<br>（4）将进程插入就绪队列。</p>
<h3 id="进程切换的时机（4种？）P88"><a href="#进程切换的时机（4种？）P88" class="headerlink" title="进程切换的时机（4种？）P88"></a>进程切换的时机（4种？）P88</h3><p>1.时钟中断<br>2.IO中断<br>3.内存失效<br>4.系统调用</p>
<h1 id="第四章——线程SMP微内核的"><a href="#第四章——线程SMP微内核的" class="headerlink" title="第四章——线程SMP微内核的"></a>第四章——线程SMP微内核的</h1><h2 id="选-3"><a href="#选-3" class="headerlink" title="选"></a>选</h2><p>无</p>
<h2 id="名-3"><a href="#名-3" class="headerlink" title="名"></a>名</h2><h3 id="什么叫做线程？-（一个独立的指令的执行序列）"><a href="#什么叫做线程？-（一个独立的指令的执行序列）" class="headerlink" title="什么叫做线程？    （一个独立的指令的执行序列）"></a>什么叫做线程？    （一个独立的指令的执行序列）</h3><h3 id="有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）"><a href="#有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）" class="headerlink" title="有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）"></a>有进程的情况下引入线程的原因（进程：拥有资源，cpu资源分配单位，进程限制了并发度，引入线程提升并发度）</h3><h3 id="什么是SMP-（概念、形式（耦合））"><a href="#什么是SMP-（概念、形式（耦合））" class="headerlink" title="什么是SMP     （概念、形式（耦合））"></a>什么是SMP     （概念、形式（耦合））</h3><p>在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是相对非对称多处理技术而言的、应用十分广泛的并行技术。</p>
<h3 id="微内核概念-（只将重要的部分作为内核实现，剩下的程序实现）"><a href="#微内核概念-（只将重要的部分作为内核实现，剩下的程序实现）" class="headerlink" title="微内核概念    （只将重要的部分作为内核实现，剩下的程序实现）"></a>微内核概念    （只将重要的部分作为内核实现，剩下的程序实现）</h3><p>模块化的设计思想，提供操作系统核心功能的内核的精简版本，只将重要的部分作为内核实现，剩下的程序实现，它设计成在很小的内存空间内增加移植性，提供模块化设计，以使用户安装不同的接口。</p>
<h3 id="宏内核概念-（把os所有功能放入内核）"><a href="#宏内核概念-（把os所有功能放入内核）" class="headerlink" title="宏内核概念    （把os所有功能放入内核）"></a>宏内核概念    （把os所有功能放入内核）</h3><p>集权控制中心，把内存管理，文件管理等功能全部管理。</p>
<h2 id="简-2"><a href="#简-2" class="headerlink" title="简"></a>简</h2><h3 id="进程与线程的关系-（从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））"><a href="#进程与线程的关系-（从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））" class="headerlink" title="进程与线程的关系  （从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））"></a>进程与线程的关系  （从概念上解释、从组成上说明差异（线程只包含指令序列中的私有数据与状态寄存器，其他都是与进程共享）、引入线程的原因（提高并发度，为什么可以提高并发度？））</h3><p>1.进程：一个正在运行的程序的实例，进程一般由程序，数据集合和进程控制块三部分组成。进程是操作系统分配资源的最小单位<br>2.线程：线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。<br>调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<h3 id="实现线程方法-（用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user-mode与kernel-mode的优点））P103"><a href="#实现线程方法-（用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user-mode与kernel-mode的优点））P103" class="headerlink" title="实现线程方法  （用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user mode与kernel mode的优点））P103"></a>实现线程方法  （用户态（不愿意冒险）、内核态（用户态验证了线程的性能、同时技术成熟）、混合型（结合user mode与kernel mode的优点））P103</h3><p>1.用户级线程:管理线程的所有工作都由应用程序完成，内核意识不到用户级线程。<br>2.内核级线程：管理线程的所有工作都由内核完成。应用级没有线程管理的代码，只有一个API，windows系统。<br>3.混合型：</p>
<h3 id="用户态进程的优缺点-和-内核态进程的优缺点P104"><a href="#用户态进程的优缺点-和-内核态进程的优缺点P104" class="headerlink" title="用户态进程的优缺点 和 内核态进程的优缺点P104"></a>用户态进程的优缺点 和 内核态进程的优缺点P104</h3><p>1.用户态线程<br>（1）优点：节省两次模式切换、调度可以根据不同的程序而定制、可在任意操作系统中运行。<br>（2）缺点：许多调用都会引起阻塞，一个syscall可能阻塞所有线程、多线程应用程序不能应用多处理技术。<br>2.内核态线程<br>（1）优点：技术成熟<br>（2）缺点：当控制权在线程之间转移时，需要切换到内核模式，耗费大。</p>
<h3 id="使用微内核的好处-（优点：，缺陷：增加了模式切换的次数。以及改进方法：1-更好的设计。2-）"><a href="#使用微内核的好处-（优点：，缺陷：增加了模式切换的次数。以及改进方法：1-更好的设计。2-）" class="headerlink" title="使用微内核的好处  （优点：，缺陷：增加了模式切换的次数。以及改进方法：1.更好的设计。2.）"></a>使用微内核的好处  （优点：，缺陷：增加了模式切换的次数。以及改进方法：1.更好的设计。2.）</h3><p>1.优点：提高了系统的可扩展性、增强了系统的可靠性、可移植性强、提供了对分布式系统的支持、融入了面向对象技术。<br>2.增加了模式切换的次数</p>
<h1 id="第五章——同步和互斥（最难）"><a href="#第五章——同步和互斥（最难）" class="headerlink" title="第五章——同步和互斥（最难）"></a>第五章——同步和互斥（最难）</h1><h2 id="选-4"><a href="#选-4" class="headerlink" title="选"></a>选</h2><h3 id="并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）"><a href="#并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）" class="headerlink" title="并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）"></a>并发和并行的异同（并发：同一时间段多个进程同时执行（交替）。并行：同一时刻，多个进程同时运行）</h3><p>1.并发：强调在一个<strong>时间段</strong>内多个进程同时执行（交替）。<br>2.并行：同一<strong>时刻</strong>，多个进程同时运行。</p>
<h3 id="互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1-中断屏蔽但多核失效。2-硬件指令：原子操作概念。3-编译器）P136"><a href="#互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1-中断屏蔽但多核失效。2-硬件指令：原子操作概念。3-编译器）P136" class="headerlink" title="互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1.中断屏蔽但多核失效。2.硬件指令：原子操作概念。3.编译器）P136"></a>互斥引入哪些机制（软件方法优缺点：用户态实现更灵活，对程序员要求高、硬件的方法：1.中断屏蔽但多核失效。2.硬件指令：原子操作概念。3.编译器）P136</h3><h2 id="名-4"><a href="#名-4" class="headerlink" title="名"></a>名</h2><h3 id="并行与并发的概念"><a href="#并行与并发的概念" class="headerlink" title="并行与并发的概念"></a>并行与并发的概念</h3><p>1.并发：强调在一个<strong>时间段</strong>内多个进程同时执行（交替）。<br>2.并行：同一<strong>时刻</strong>，多个进程同时运行。</p>
<h3 id="互斥的概念"><a href="#互斥的概念" class="headerlink" title="互斥的概念"></a>互斥的概念</h3><p>进程互斥是<strong>进程之间的间接制约关系</strong>。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。</p>
<h3 id="overlap（覆盖技术）"><a href="#overlap（覆盖技术）" class="headerlink" title="overlap（覆盖技术）"></a>overlap（覆盖技术）</h3><p>覆盖是将程序划分为bai若干个功能上相对独立的程序段，du按照程序的逻辑结构让那些zhi不会同时执行的程序段共享同dao一块内存区的内存扩充技术。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。</p>
<h3 id="临界区：Cirtical-section"><a href="#临界区：Cirtical-section" class="headerlink" title="临界区：Cirtical section"></a>临界区：<strong>Cirtical section</strong></h3><p>使用临界资源的那部分程序成为程序的<strong>临界区</strong>，一次只允许一个程序在临界区中。</p>
<h3 id="race-condition（条件竞争）P132"><a href="#race-condition（条件竞争）P132" class="headerlink" title="race condition（条件竞争）P132"></a>race condition（条件竞争）P132</h3><p>发生在多个<strong>进程或线程</strong>读写数据时，其最终结果<strong>取决于多个进程的指令执行顺序</strong>。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作可以是一个步骤，也可以是多个操作步骤，但是其<strong>顺序不可以被打乱</strong>，<strong>也不可以被切割而只执行其中的一部分</strong>。将整个操作视作<strong>一个整体</strong>是原子性的核心特征。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用于进程间通信的整数值。只允许三个操作。<br><img src="https://s1.ax1x.com/2020/06/25/NBpidg.png" alt=""></p>
<h3 id="……-（有张表上所有概念都要掌握）"><a href="#……-（有张表上所有概念都要掌握）" class="headerlink" title="…….（有张表上所有概念都要掌握）"></a>…….（有张表上所有概念都要掌握）</h3><p><img src="https://s1.ax1x.com/2020/06/25/NBSGKf.png" alt=""></p>
<h2 id="简-3"><a href="#简-3" class="headerlink" title="简"></a>简</h2><h3 id="并发中解决的四个问题-P130"><a href="#并发中解决的四个问题-P130" class="headerlink" title="并发中解决的四个问题 P130"></a>并发中解决的四个问题 P130</h3><p>1.全局资源共享的危险。<br>2.os很难对资源进行最优化分配<br>3.定位错误非常难</p>
<h3 id="信号量的类型（一般互斥计数强弱）"><a href="#信号量的类型（一般互斥计数强弱）" class="headerlink" title="信号量的类型（一般互斥计数强弱）"></a>信号量的类型（一般互斥计数强弱）</h3><p>1.一般信号量<br>2.互斥信号量<br>3.二元信号量<br>4.强/弱信号量：依照进程从队列中移出的顺序，最公平的是FIFO：被阻塞最久的的进程最先释放（基于这一策略定义的叫强信号量）。而没有规定策略的叫弱信号量。<br>5.计数信号量</p>
<h3 id="实现互斥的三种方法（信号量、管程……）"><a href="#实现互斥的三种方法（信号量、管程……）" class="headerlink" title="实现互斥的三种方法（信号量、管程……）"></a>实现互斥的三种方法（信号量、管程……）</h3><p>1.信号量<br>2.管程：P138.本质上是一种特殊的程序设计语言结构，功能与信号量相同但更易于控制。<br>3.进程间消息传递</p>
<h3 id="硬件上如何实现互斥同步（swap、test）"><a href="#硬件上如何实现互斥同步（swap、test）" class="headerlink" title="硬件上如何实现互斥同步（swap、test）"></a>硬件上如何实现互斥同步（swap、test）</h3><p><a href="https://blog.csdn.net/weixin_42333573/article/details/103571740" target="_blank" rel="noopener">硬件同步机制中test-and-set指令和swap指令实现的详解</a></p>
<h2 id="计"><a href="#计" class="headerlink" title="计"></a>计</h2><h3 id="生产者消费者、读者写者问题"><a href="#生产者消费者、读者写者问题" class="headerlink" title="生产者消费者、读者写者问题"></a>生产者消费者、读者写者问题</h3><h1 id="第六章——并发：死锁和饥饿"><a href="#第六章——并发：死锁和饥饿" class="headerlink" title="第六章——并发：死锁和饥饿"></a>第六章——并发：死锁和饥饿</h1><h2 id="选-5"><a href="#选-5" class="headerlink" title="选"></a>选</h2><h3 id="死锁与饥饿（资源向量、可用资源向量等）"><a href="#死锁与饥饿（资源向量、可用资源向量等）" class="headerlink" title="死锁与饥饿（资源向量、可用资源向量等）"></a>死锁与饥饿（资源向量、可用资源向量等）</h3><p>（1）死锁：相互竞争系统资源或进程间的<strong>永久阻塞</strong><br>（2）饥饿：一个可运行的进程尽管能继续执行，但被调度程序无限期的忽视而不能被调度执行的情况。<br>（3）资源向量：<br>（4）可用资源向量：<br><img src="https://s1.ax1x.com/2020/06/25/NBit4e.png" alt=""></p>
<h3 id="死锁活锁饥饿"><a href="#死锁活锁饥饿" class="headerlink" title="死锁活锁饥饿"></a>死锁活锁饥饿</h3><p>（1）活锁：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开。</p>
<p><a href="https://blog.csdn.net/qq_22054285/article/details/87911464" target="_blank" rel="noopener">死锁、活锁、饥饿</a></p>
<h2 id="简-4"><a href="#简-4" class="headerlink" title="简"></a>简</h2><h3 id="死锁的必要条件x3"><a href="#死锁的必要条件x3" class="headerlink" title="死锁的必要条件x3"></a>死锁的必要条件x3</h3><p>（1）互斥<br>（2）占有且等待<br>（3）不可抢占</p>
<h3 id="死锁的充要条件x4"><a href="#死锁的充要条件x4" class="headerlink" title="死锁的充要条件x4"></a>死锁的充要条件x4</h3><p>（1）互斥<br>（2）占有且等待<br>（3）不可抢占<br>（4）循环等待</p>
<h3 id="解决死锁的方法（3-or-4大类：死锁预防、避免、检测、消除、鸵鸟）P177"><a href="#解决死锁的方法（3-or-4大类：死锁预防、避免、检测、消除、鸵鸟）P177" class="headerlink" title="解决死锁的方法（3 or 4大类：死锁预防、避免、检测、消除、鸵鸟）P177"></a>解决死锁的方法（3 or 4大类：死锁预防、避免、检测、消除、鸵鸟）P177</h3><p>（1）死锁预防：允许三个必要条件，<strong>但通过选择可确保永远不会到达死锁点</strong>，可允许更多的并发。<br>（2）死锁避免：约束资源请求至少可破坏四个死锁条件中的一个条件，会导致资源使用和低效的进程执行。需要知道未来资源请求的情况。“是否允许当前资源分配请求是通过判断该请求是否可能导致死锁来决定的”，<strong>包含进程启动拒绝、资源分配拒绝（银行家算法）</strong><br>（3）死锁检测：不限制资源访问或约束的行为，频繁的在每个资源请求时发生，也可以进行的少一些，具体取决于发生死锁的可能性。耗费处理器时间。P181，“假设统一这些资源，让进程运行到结束，再释放他的资源”。<strong>不能保证防止死锁，是否死锁取决于将来的同意请求的次序，他所做的一切都是确定当前是否存在死锁</strong><br><img src="https://s1.ax1x.com/2020/06/25/NBAMcj.png" alt=""></p>
<h3 id="死锁与饥饿的关系"><a href="#死锁与饥饿的关系" class="headerlink" title="死锁与饥饿的关系"></a>死锁与饥饿的关系</h3><p>进程会处于饥饿状态是因为持续地有其它优先级更高的进程请求相同的资源。不像死锁或者活锁，饥饿能够被解开。例如，当其它高优先级的进程都终止时并且没有更高优先级的进程到达。<br><img src="https://s1.ax1x.com/2020/06/25/NBA5DI.png" alt=""><br><a href="https://blog.csdn.net/liudongdong19/article/details/80294055" target="_blank" rel="noopener">死锁与饥饿</a></p>
<h2 id="计-1"><a href="#计-1" class="headerlink" title="计"></a>计</h2><h3 id="银行家算法（算新的请求能不能分配）"><a href="#银行家算法（算新的请求能不能分配）" class="headerlink" title="银行家算法（算新的请求能不能分配）"></a>银行家算法（算新的请求能不能分配）</h3><h3 id="死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）"><a href="#死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）" class="headerlink" title="死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）"></a>死锁检测算法（判断当前状态是否有死锁进程，若有，是哪些）</h3><h3 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h3><h1 id="第七章——内存管理"><a href="#第七章——内存管理" class="headerlink" title="第七章——内存管理"></a>第七章——内存管理</h1><h2 id="选-6"><a href="#选-6" class="headerlink" title="选"></a>选</h2><h3 id="段表和页表（构造、结构、如何-什么时候使用）"><a href="#段表和页表（构造、结构、如何-什么时候使用）" class="headerlink" title="段表和页表（构造、结构、如何/什么时候使用）"></a>段表和页表（构造、结构、如何/什么时候使用）</h3><p>（1）页表 P213<br>分页：类似于固定分区<br>操作系统为每个进程维护一个页表。而进程中的page在内存中以页框（frame）为单位载入。给出逻辑地址后（页号 ，偏移量）处理器使用页表产生物理地址（页框号、偏移量）。进程的每一页在页表中都有一项，因此页表很容易按照页号对进程的所有页进行索引。<br>使用方法：<img src="https://s1.ax1x.com/2020/06/25/NB3yy6.png" alt=""><br>（2）段表 P215<br>分段：类似于动态分区（消除了内部碎片）<br>每个进程都有一个段表，每个段 表项给出相应段在内存中的起始地址，以及段长度<br>使用方法：<img src="https://s1.ax1x.com/2020/06/25/NB36OK.png" alt=""></p>
<h2 id="名-5"><a href="#名-5" class="headerlink" title="名"></a>名</h2><h3 id="重定位-P205"><a href="#重定位-P205" class="headerlink" title="重定位 P205"></a>重定位 P205</h3><p><img src="https://s1.ax1x.com/2020/06/25/NBmPm9.png" alt=""><br>在多道程序设计系统中，可用的内存空间通常被多个程序共享。重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程。它是实现多道程序在内存中同时运行的基础。重定位有两种，分别是动态重定位与静态重定位。</p>
<h3 id="覆盖overlaying"><a href="#覆盖overlaying" class="headerlink" title="覆盖overlaying"></a>覆盖overlaying</h3><p>当供程序使用的内存不足时，此时，程序员采用覆盖技术（overlaying）来组织程序和数据。不同的模块被分配到内存的同一区域，主程序负责在需要时换入换出模块。</p>
<h3 id="逻辑、物理、相对地址-P212"><a href="#逻辑、物理、相对地址-P212" class="headerlink" title="逻辑、物理、相对地址 P212"></a>逻辑、物理、相对地址 P212</h3><p>（1）逻辑地址：当前数据在内存中的物理分配地址无关的访问地址，在执行对其的访问之前必须转换为物理地址。其表达形式为“段地址：段内偏移地址”。<br>（2）物理地址：在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址，又叫实际地址或绝对地址。CPU与存储器进行数据交换时在地址总线上<br>（3）相对地址：相对地址和绝对地址都属于逻辑地址。他们之间的区别，绝对地址是相对于整个进程的地址；一个进程可能会被分成多个部分(比如说分段系统中一个进程被分为多个段)，<strong>相对地址是相对于进程当前部分(比如说分段系统的当前段)的地址</strong>。</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换是指先将内存某部分的程序或数据写入外存交换区，再从外存交换区中调入指定的程序或数据到内存中来，并让其执行的一种内存扩充技术。</p>
<h3 id="碎片（内部与外部）"><a href="#碎片（内部与外部）" class="headerlink" title="碎片（内部与外部）"></a>碎片（内部与外部）</h3><p>（1）内部碎片：内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；内部碎片是处于（操作系统分配的用于装载某一进程的内存）区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。（比如你用固定分区，一个2M的程序占有一个8M的分区）<br>（2）外部碎片：外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。（举个例子，在内存上，分配三个操作系统分配的用于装载进程的内存区域A、B和C。假设，三个内存区域都是相连的。故而三个内存区域不会产生外部碎片。现在假设B对应的进程执行完毕了操作系统随即收回了B，这个时候A和C中间就有一块空闲区域了）</p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>作为固定分区和动态分区的折中。不断的分裂。<br><img src="https://s1.ax1x.com/2020/06/25/NBMc5R.png" alt=""></p>
<h2 id="简-5"><a href="#简-5" class="headerlink" title="简"></a>简</h2><h3 id="内存管理几种方法与联系差异（分段与固定分区等）P206"><a href="#内存管理几种方法与联系差异（分段与固定分区等）P206" class="headerlink" title="内存管理几种方法与联系差异（分段与固定分区等）P206-"></a>内存管理几种方法与联系差异（分段与固定分区等）P206-</h3><p><img src="https://s1.ax1x.com/2020/06/25/NBnm40.png" alt=""></p>
<h3 id="首次适应、最佳匹配、最坏匹配等-P209"><a href="#首次适应、最佳匹配、最坏匹配等-P209" class="headerlink" title="首次适应、最佳匹配、最坏匹配等 P209"></a>首次适应、最佳匹配、最坏匹配等 P209</h3><p>放置算法的引入可以缓解使用压缩（compaction）机制是造成的费时。<br>（1）首次适应（first-fit）：从头扫描内存，选择第一个可用块。<br>（2）最佳适应（best-fit）：选择与要求大小接近的块<br>（3）最坏匹配（next-fit）：从上一次放置的位置开始扫描内存，选择下一个大小足够的块</p>
<h3 id="伙伴系统内存分配与回收"><a href="#伙伴系统内存分配与回收" class="headerlink" title="伙伴系统内存分配与回收"></a>伙伴系统内存分配与回收</h3><p>P210-211</p>
<h3 id="简单分段与分页的要点（逻辑地址到物理地址转换：1-2-3-4-）"><a href="#简单分段与分页的要点（逻辑地址到物理地址转换：1-2-3-4-）" class="headerlink" title="简单分段与分页的要点（逻辑地址到物理地址转换：1.2.3.4.）"></a>简单分段与分页的要点（逻辑地址到物理地址转换：1.2.3.4.）</h3><p>见本章选择题那两张图片</p>
<h1 id="第八章——虚拟存储"><a href="#第八章——虚拟存储" class="headerlink" title="第八章——虚拟存储"></a>第八章——虚拟存储</h1><h2 id="选-7"><a href="#选-7" class="headerlink" title="选"></a>选</h2><h3 id="七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。"><a href="#七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。" class="headerlink" title="七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。"></a>七种内存分配方法演变的历程：固定分区、动态分区、简单分页、简单分段、虚存分页、虚存分段、同时采用分页和分段。</h3><p><img src="https://s1.ax1x.com/2020/06/25/NBbYwR.png" alt=""></p>
<h3 id="如何理解虚拟存储器-P224"><a href="#如何理解虚拟存储器-P224" class="headerlink" title="如何理解虚拟存储器 P224"></a>如何理解虚拟存储器 P224</h3><p>由于进程只能在内存中执行，因此这个存储器称为实存储器。但程序员或用户感受到的是一个更大的内存，且通常<strong>分配在磁盘上</strong>，这称为虚拟内存。</p>
<h3 id="引入虚拟存储器后地址空间是什么样子-P226-227"><a href="#引入虚拟存储器后地址空间是什么样子-P226-227" class="headerlink" title="引入虚拟存储器后地址空间是什么样子 P226-227"></a>引入虚拟存储器后地址空间是什么样子 P226-227</h3><p><a href="https://blog.csdn.net/u014379540/article/details/52263114" target="_blank" rel="noopener"></a></p>
<h3 id="保护和共享（段、页表）P223"><a href="#保护和共享（段、页表）P223" class="headerlink" title="保护和共享（段、页表）P223"></a>保护和共享（段、页表）P223</h3><p>环状保护，编号小的内环比外环有更大的特权<br><img src="https://s1.ax1x.com/2020/06/25/NBjfsO.png" alt=""></p>
<h3 id="实现虚拟存储器需要哪些硬件支持"><a href="#实现虚拟存储器需要哪些硬件支持" class="headerlink" title="实现虚拟存储器需要哪些硬件支持"></a>实现虚拟存储器需要哪些硬件支持</h3><p>（1）请求分页/段的页表或段表机制：请求分页存储管理是建立在分页存储管埋的基础上，并结合虚拟存储系统原理实现的，是目前常用的一种实现虚拟存储器的方式<br>（2）缺页/段中断机制：作用就是就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。<br>（3）地址变换机构。</p>
<h2 id="名-6"><a href="#名-6" class="headerlink" title="名"></a>名</h2><h3 id="page-fault"><a href="#page-fault" class="headerlink" title="page fault"></a>page fault</h3><p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>在请求分页存储管理中，从主存（DRAM）中刚刚换出（Swap Out）某一页面后（换出到Disk），根据请求马上又换入（Swap In）该页，这种反复换出换入的现象，称为系统颠簸，也叫系统抖动。产生该现象的主要原因是置换算法选择不当。（处理器进行交换页面的时间大于实际执行程序的时间）</p>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><p>使用页框号而不是虚拟页号来索引页表项.在这种方法中，虚拟地址的页号部分使用一个简单的散列函数映射到散列表中。散列表包含一个指向倒排表的指针,而倒排表中含有页表项.通过这个结构,散列表和倒排表中各有一项对应于一个实存页.因此,不论有多少个进程、支持多少虚拟页，页表的大小都是固定的。如图,页表的共有为2的m次方个项.<br><a href="https://blog.csdn.net/qyanqing/article/details/9381859?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">虚拟内存之倒排页表</a></p>
<h3 id="TLB，转换检测缓冲区）"><a href="#TLB，转换检测缓冲区）" class="headerlink" title="TLB，转换检测缓冲区）"></a>TLB，转换检测缓冲区）</h3><p>一个特殊的高速缓存。给定一个虚拟地址，首先检查TLB，若需要的页表项在其中（TLB命中）则检索页框号形成实地址。若tlb未命中，处理器用页号查找进程的页表。若存在未已经置位，则更新tlb，使其包含这个页表项。</p>
<h3 id="页缓冲-P244"><a href="#页缓冲-P244" class="headerlink" title="页缓冲 P244"></a>页缓冲 P244</h3><p>通过页缓冲技术，被置换的页可以放在两个表中，修改表和未修改表。</p>
<h3 id="虚拟存储器中的一些策略：加载、清楚-etc-P243-244"><a href="#虚拟存储器中的一些策略：加载、清楚-etc-P243-244" class="headerlink" title="虚拟存储器中的一些策略：加载、清楚 etc. P243-244"></a>虚拟存储器中的一些策略：加载、清楚 etc. P243-244</h3><p>1.清除<br>（1）请求式清除<br>（2）预约式清除<br>（3）结合页缓冲<br>2.加载控制 P244<br>影响/控制驻留在内存中的进程数量，即系统并发度。</p>
<h3 id="虚存的空间分配"><a href="#虚存的空间分配" class="headerlink" title="虚存的空间分配"></a>虚存的空间分配</h3><p><a href="https://www.cnblogs.com/panchanggui/p/9288389.html" target="_blank" rel="noopener">Linux 虚拟内存和物理内存的理解</a></p>
<h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h3 id="虚存实现方法（请求分页分段以及）"><a href="#虚存实现方法（请求分页分段以及）" class="headerlink" title="虚存实现方法（请求分页分段以及）"></a>虚存实现方法（请求分页分段以及）</h3><p>1.请求式分段<br>2.请求式分页<br>3.段页式</p>
<h3 id="缺页中断处理流程"><a href="#缺页中断处理流程" class="headerlink" title="缺页中断处理流程"></a>缺页中断处理流程</h3><p><a href="https://blog.csdn.net/pxz_002/article/details/7323990?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">缺页中断处理过程详解</a></p>
<h3 id="分页分段地址翻译过程"><a href="#分页分段地址翻译过程" class="headerlink" title="分页分段地址翻译过程"></a>分页分段地址翻译过程</h3><p><img src="https://s1.ax1x.com/2020/06/25/NBzzwD.png" alt=""><br><img src="https://s1.ax1x.com/2020/06/25/NDSPfA.png" alt=""><br><img src="https://s1.ax1x.com/2020/06/25/NDSA6P.png" alt=""></p>
<h3 id="虚存中段、页表数据结构"><a href="#虚存中段、页表数据结构" class="headerlink" title="虚存中段、页表数据结构"></a>虚存中段、页表数据结构</h3><p>类似简单分页和分段。但此时页表项会更加复杂。并且由于此时每个进程可能只有一些页在内存中，因而每个表项需要有一位（P）来表示他所对应的页当前是否在内存中。若这一位表示改页在内存中，则这个页表项还包括该页的页框号。页表项中所需要的另一个控制位是修改位（M）他表示相应的页的内容从上次装入内存到现在是否已经改变。若未改变，在把该页换出时，无需用页框中的内容更新页。还有一些其他的控制位比如想在页一级实现保护或共享。<img src="https://s1.ax1x.com/2020/06/25/NBXpng.png" alt=""></p>
<h3 id="多级页表的原因以及优缺点"><a href="#多级页表的原因以及优缺点" class="headerlink" title="多级页表的原因以及优缺点"></a>多级页表的原因以及优缺点</h3><p>（优点）<br>（1）<strong>使用多级页表可以使得页表在内存中离散存储</strong>。多级页表实际上是增加了索引，有了索引就可以定位到具体的项。举个例子：比如虚拟地址空间大小为4G，每个页大小依然为4K，如果使用一级页表的话，共有2^20个页表项，如果每一个页表项占4B，那么存放所有页表项需要4M，为了能够随机访问，那么就需要连续4M的内存空间来存放所有的页表项。随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。但是如果使用多级页表，我们可以使用一页来存放页目录项，页表项存放在内存中的其他位置，不用保证页目录项和页表项连续。<br>（2）<strong>使用多级页表可以节省页表内存</strong>。使用一级页表，需要连续的内存空间来存放所有的页表项。多级页表通过只为进程实际使用的那些虚拟地址内存区请求页表来减少内存使用量（出自《深入理解Linux内核》第三版51页）。举个例子：一个进程的虚拟地址空间是4GB，假如进程只使用4MB内存空间。对于一级页表，我们需要4M空间来存放这4GB虚拟地址空间对应的页表，然后可以找到进程真正使用的4M内存空间。也就是说，虽然进程实际上只使用了4MB的内存空间，但是为了访问它们我们需要为所有的虚拟地址空间建立页表。但是如果使用二级页表的话，一个页目录项可以定位4M内存空间，存放一个页目录项占4K，还需要一页用于存放进程使用的4M（4M=1024<em>4K，也就是用1024个页表项可以映射4M内存空间）内存空间对应的页表，总共需要4K（页表）+4K（页目录）=8K来存放进程使用的这4M内存空间对应页表和页目录项，这比使用一级页表节省了很多内存空间。当然，在这种情况下，使用多级页表确实是可以节省内存的。但是，我们需要注意另一种情况，如果进程的虚拟地址空间是4GB，而进程真正使用的内存也是4GB，如果是使用一级页表，则只需要4MB连续的内存空间存放页表，我们就可以寻址这4GB内存空间。而如果使用的是二级页表的话，我们需要4MB内存存放页表，还需要4KB内存来存放页目录项，此时多级页表反倒是多占用了内存空间。注意在大多数情况都是进程的4GB虚拟地址空间都是没有使用的，实际使用的都是小于4GB的，所以我们说多级页表可以节省页表内存。<br>（缺点）<br>*</em>增加寻址次数，从而延长访存时间**。比如：使用以及页表时，读取内存中一页内容需要2次访问内存，第一次是访问页表项，第二次是访问要读取的一页数据。但如果是使用二级页表的话，就需要3次访问内存了，第一次访问页目录项，第二次访问页表项，第三次访问要读取的一页数据。</p>
<h3 id="驻留集中的几个变化-P224"><a href="#驻留集中的几个变化-P224" class="headerlink" title="驻留集中的几个变化 P224"></a>驻留集中的几个变化 P224</h3><p>1.在内存中保留多个进程<br>2.进程可以比内存的全部空间还大</p>
<h2 id="计-2"><a href="#计-2" class="headerlink" title="计"></a>计</h2><h3 id="页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断-P236"><a href="#页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断-P236" class="headerlink" title="页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断 P236"></a>页面调度置换算法（计算缺页中断率），内存为空是也算缺页中断 P236</h3><h1 id="第九章——单处理器调度"><a href="#第九章——单处理器调度" class="headerlink" title="第九章——单处理器调度"></a>第九章——单处理器调度</h1><h2 id="选-8"><a href="#选-8" class="headerlink" title="选"></a>选</h2><h3 id="进程调度切换抢占等"><a href="#进程调度切换抢占等" class="headerlink" title="进程调度切换抢占等"></a>进程调度切换抢占等</h3><h2 id="名-7"><a href="#名-7" class="headerlink" title="名"></a>名</h2><h3 id="长、中、短程调度"><a href="#长、中、短程调度" class="headerlink" title="长、中、短程调度"></a>长、中、短程调度</h3><p>（1）长程调度：决定那个程序可以进入系统中处理，他控制了系统的并发度，并添加到供短程调度程序使用的队列中，等待调度。<br>（2）中程调度：是交换功能的一部分（换入换出）<br>（3）短程调度：也称为分派程序（dispatcher），他精确的决定下次执行哪个进程.(引起短程调度：时钟中断、IO中断、syscall、信号（信号量）)</p>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>当前运行的进程可能被系统中断并处于就绪态。一个新进程到达时，或中断发生后把一个阻塞态进程置为就绪态时，或出现周期性的时间中断时，需要进行抢占决策。</p>
<h2 id="简-6"><a href="#简-6" class="headerlink" title="简"></a>简</h2><h3 id="长、中、短程调度含义以及状态图变化有哪些"><a href="#长、中、短程调度含义以及状态图变化有哪些" class="headerlink" title="长、中、短程调度含义以及状态图变化有哪些"></a>长、中、短程调度含义以及状态图变化有哪些</h3><p><img src="https://s1.ax1x.com/2020/06/25/NDalXd.png" alt=""><br><img src="https://s1.ax1x.com/2020/06/25/NDa3nA.png" alt=""></p>
<h3 id="三种调度类型的一些概念：比如到达时间等"><a href="#三种调度类型的一些概念：比如到达时间等" class="headerlink" title="三种调度类型的一些概念：比如到达时间等"></a>三种调度类型的一些概念：比如到达时间等</h3><p><img src="https://s1.ax1x.com/2020/06/25/NDaa9S.png" alt=""></p>
<h2 id="计-3"><a href="#计-3" class="headerlink" title="计"></a>计</h2><h3 id="进程调度算法-P262"><a href="#进程调度算法-P262" class="headerlink" title="进程调度算法 P262"></a>进程调度算法 P262</h3><h2 id="另"><a href="#另" class="headerlink" title="另"></a>另</h2><p>表9.5 图9.5</p>
<h1 id="第11章——IO"><a href="#第11章——IO" class="headerlink" title="第11章——IO"></a>第11章——IO</h1><h2 id="选-9"><a href="#选-9" class="headerlink" title="选"></a>选</h2><h3 id="IO模块的功能-P312"><a href="#IO模块的功能-P312" class="headerlink" title="IO模块的功能 P312"></a>IO模块的功能 P312</h3><p>有自己的局部储存器。可以控制许多IO设备，降低CPU的参与度，IO处理器大多数负责控制终端的任务。</p>
<h3 id="IO模块的层次设计（三张图）"><a href="#IO模块的层次设计（三张图）" class="headerlink" title="IO模块的层次设计（三张图）"></a>IO模块的层次设计（三张图）</h3><p>（1）逻辑IO<br>（2）设备IO<br>（3）调度与控制<img src="https://s1.ax1x.com/2020/06/26/NDshin.png" alt=""></p>
<h2 id="名-8"><a href="#名-8" class="headerlink" title="名"></a>名</h2><h3 id="什么是块设备-P315"><a href="#什么是块设备-P315" class="headerlink" title="什么是块设备 P315"></a>什么是块设备 P315</h3><p>block-oriend：设备信息保存在块中，块的大小通常是固定的，传送中一次传送一块。通常可以通过块号访问数据。（磁盘、usb等等）</p>
<h3 id="什么是流设备"><a href="#什么是流设备" class="headerlink" title="什么是流设备"></a>什么是流设备</h3><p>stream-oriented：以字节流的方式输入输出数据，他没有块结构。终端、打印机、通信端口、鼠标和其他指示设备以及其他大多数非辅存设备，都属于面向流的设备。</p>
<h2 id="简-7"><a href="#简-7" class="headerlink" title="简"></a>简</h2><h3 id="引入IO缓冲原因"><a href="#引入IO缓冲原因" class="headerlink" title="引入IO缓冲原因"></a>引入IO缓冲原因</h3><p>(1)缓和CPU与I/O设备间速度不匹配的矛盾。<br>(2)减少对CPU的中断的频率，放宽对中断响应时间的限制。<br>(3)提高CPU与I/O设备之间的并行操作程度。提高系统效率与单个进程性能</p>
<h3 id="IO缓冲三种方式-P316"><a href="#IO缓冲三种方式-P316" class="headerlink" title="IO缓冲三种方式 P316"></a>IO缓冲三种方式 P316</h3><p>（1）单缓冲：输入传送的数据被放到系统缓冲区中，当传送完毕时，进程把该块移动到用户空间，并立即请求另一块。（预先读入）<br>（2）双缓冲（缓冲交换）：在一个进程向一个缓冲区中传送数据时，同时操作系统正在清空另一个缓冲区。<br>（3）循环缓冲：一个IO密集型进程时，多个缓冲区来跟上这个进程<img src="https://s1.ax1x.com/2020/06/26/ND6mN9.png" alt=""></p>
<h3 id="磁盘调度中的延迟（5个）P318"><a href="#磁盘调度中的延迟（5个）P318" class="headerlink" title="磁盘调度中的延迟（5个）P318"></a>磁盘调度中的延迟（5个）P318</h3><p>（1）寻道时间<br>（2）旋转延迟<br>（3）存取时间access time<br>（4）传输时间</p>
<h2 id="计-4"><a href="#计-4" class="headerlink" title="计"></a>计</h2><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h1 id="第12章——文件管理"><a href="#第12章——文件管理" class="headerlink" title="第12章——文件管理"></a>第12章——文件管理</h1><h2 id="选-10"><a href="#选-10" class="headerlink" title="选"></a>选</h2><h3 id="为什么需要文件系统"><a href="#为什么需要文件系统" class="headerlink" title="为什么需要文件系统"></a>为什么需要文件系统</h3><p>便于长期储存信息以即用户或应用程序来访问信息</p>
<h3 id="文件系统目标-P342"><a href="#文件系统目标-P342" class="headerlink" title="文件系统目标 P342"></a>文件系统目标 P342</h3><p><img src="https://s1.ax1x.com/2020/06/26/ND6a9I.png" alt=""></p>
<h3 id="文件系统架构-P343"><a href="#文件系统架构-P343" class="headerlink" title="文件系统架构 P343"></a>文件系统架构 P343</h3><p>（1）设备驱动<br>（2）基本IO管理<br>（3）逻辑IO<br>（4）文件管理功能<br><img src="https://s1.ax1x.com/2020/06/26/ND6Du8.png" alt=""></p>
<h2 id="名-9"><a href="#名-9" class="headerlink" title="名"></a>名</h2><h3 id="什么是文件-P340"><a href="#什么是文件-P340" class="headerlink" title="什么是文件 P340"></a>什么是文件 P340</h3><p>一篇文章、一段视频、一个可执行程序，都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据。<br>文件有一些理想属性：长期存在、可在进程共享、结构。</p>
<h3 id="文件系统概念-P340"><a href="#文件系统概念-P340" class="headerlink" title="文件系统概念 P340"></a>文件系统概念 P340</h3><p>文件系统是os的重要组成部分。文件系统允许用户创建称为文件的数据集。</p>
<h3 id="文件管理系统的概念-P342"><a href="#文件管理系统的概念-P342" class="headerlink" title="文件管理系统的概念 P342"></a>文件管理系统的概念 P342</h3><p>文件管理系统是一组系统软件，他为使用文件的用户和应用程序提供服务。</p>
<h3 id="文件系统层次结构-P343"><a href="#文件系统层次结构-P343" class="headerlink" title="文件系统层次结构 P343"></a>文件系统层次结构 P343</h3><p><img src="https://s1.ax1x.com/2020/06/26/ND6Du8.png" alt=""></p>
<h3 id="文件分配表、相对与绝对路径"><a href="#文件分配表、相对与绝对路径" class="headerlink" title="文件分配表、相对与绝对路径"></a>文件分配表、相对与绝对路径</h3><p>文件分配表FAT（File Allocation Table），指的是用来记录文件所在位置的表格。<br>相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。<br>绝对路径是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。完整的描述文件位置的路径就是绝对路径。</p>
<h2 id="简-8"><a href="#简-8" class="headerlink" title="简"></a>简</h2><h3 id="文件组织形式（堆、顺序等5种）P345-346"><a href="#文件组织形式（堆、顺序等5种）P345-346" class="headerlink" title="文件组织形式（堆、顺序等5种）P345-346"></a>文件组织形式（堆、顺序等5种）P345-346</h3><p>（1）堆<br>（2）顺序文件<br>（3）索引顺序文件<br>（4）索引文件<br>（5）直接或散列文件</p>
<h3 id="物理层次上文件的结构（外存上面）"><a href="#物理层次上文件的结构（外存上面）" class="headerlink" title="物理层次上文件的结构（外存上面）"></a>物理层次上文件的结构（外存上面）</h3><p>B树（提供高效的搜索、增加、删除索引项的操作） P347</p>
<h3 id="目录的实现方式"><a href="#目录的实现方式" class="headerlink" title="目录的实现方式"></a>目录的实现方式</h3><p>树状结构目录 P351</p>
<p><del>by ScUpax0s</del></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Paxos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/">http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/06/16/NPdUZ6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/12/linux-%E5%86%85%E6%A0%B8pwn-0/"><img class="prev_cover" src="https://s1.ax1x.com/2020/07/14/UNnv1P.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">linux 内核pwn (0)</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/21/BUUoj-rctf2018-babyheap-off-by-null/"><img class="next_cover" src="https://s1.ax1x.com/2020/06/21/N8aQLd.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">BUUoj-rctf2018_babyheap-off-by-null</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%B8%8E%E5%A4%8D%E4%B9%A0/';
  this.page.identifier = '2020/06/26/操作系统相关概念整理与复习/';
  this.page.title = '操作系统相关概念整理与复习';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://ScUpax0s.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script><script>function getDisqusCount() {
  var d = document, s = d.createElement('script');
  s.src = 'https://ScUpax0s.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
}

window.addEventListener('load', getDisqusCount, false);</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Paxos</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>