<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux内核基础学习笔记 | ScUpax0s</title><meta name="description" content="Booting阶段启动1.按下电源开关，主板发送信号到电源，电源准备合适的电量，向主板发送备妥信号，启动CPU。 2.CPU启动，寄存器复位。    123IP          0xfff0CS selector 0xf000CS base     0xffff0000 3.CPU此时工作在实模式，采用分段管理内存，无分页， Cache、TLB（Translation Lookup Table）"><meta name="author" content="Paxos"><meta name="copyright" content="Paxos"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux内核基础学习笔记"><meta name="twitter:description" content="Booting阶段启动1.按下电源开关，主板发送信号到电源，电源准备合适的电量，向主板发送备妥信号，启动CPU。 2.CPU启动，寄存器复位。    123IP          0xfff0CS selector 0xf000CS base     0xffff0000 3.CPU此时工作在实模式，采用分段管理内存，无分页， Cache、TLB（Translation Lookup Table）"><meta name="twitter:image" content="https://s1.ax1x.com/2020/07/16/UDSEZ9.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Linux内核基础学习笔记"><meta property="og:url" content="http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="ScUpax0s"><meta property="og:description" content="Booting阶段启动1.按下电源开关，主板发送信号到电源，电源准备合适的电量，向主板发送备妥信号，启动CPU。 2.CPU启动，寄存器复位。    123IP          0xfff0CS selector 0xf000CS base     0xffff0000 3.CPU此时工作在实模式，采用分段管理内存，无分页， Cache、TLB（Translation Lookup Table）"><meta property="og:image" content="https://s1.ax1x.com/2020/07/16/UDSEZ9.jpg"><meta property="article:published_time" content="2020-07-16T06:57:02.000Z"><meta property="article:modified_time" content="2020-07-19T10:02:33.154Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"><link rel="prev" title="SROP+栈迁移_VN2020公开赛pwn" href="http://yoursite.com/2020/07/20/SROP-%E6%A0%88%E8%BF%81%E7%A7%BB-VN2020%E5%85%AC%E5%BC%80%E8%B5%9Bpwn/"><link rel="next" title="Linux Kernel pwn(0)——kernel ROP与ret2usr" href="http://yoursite.com/2020/07/12/linux-%E5%86%85%E6%A0%B8pwn-0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/15/N9ZTBV.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">67</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-diamond" aria-hidden="true"></i><span> Life</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments-o"></i><span> talk</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Booting阶段"><span class="toc-number">1.</span> <span class="toc-text">Booting阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动"><span class="toc-number">1.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进入内核前的准备"><span class="toc-number">1.2.</span> <span class="toc-text">进入内核前的准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进入内核"><span class="toc-number">1.3.</span> <span class="toc-text">进入内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进入保护模式之前的准备"><span class="toc-number">1.3.1.</span> <span class="toc-text">进入保护模式之前的准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进入保护模式"><span class="toc-number">1.3.2.</span> <span class="toc-text">进入保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从32位保护模式向64位长模式切换"><span class="toc-number">1.3.3.</span> <span class="toc-text">从32位保护模式向64位长模式切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核解压"><span class="toc-number">1.3.4.</span> <span class="toc-text">内核解压</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">2.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://s1.ax1x.com/2020/07/16/UDSEZ9.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ScUpax0s</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-diamond" aria-hidden="true"></i><span> Life</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments-o"></i><span> talk</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Linux内核基础学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-16 14:57:02"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-07-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-07-19 18:02:33"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-07-19</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kernel/">kernel</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><span class="disqus-comment-count comment-count"><a href="http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/#disqus_thread"></a></span></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Booting阶段"><a href="#Booting阶段" class="headerlink" title="Booting阶段"></a>Booting阶段</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1.按下电源开关，主板发送信号到电源，电源准备合适的电量，向主板发送备妥信号，启动CPU。</p>
<p>2.CPU启动，寄存器复位。<br>    <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IP</span>          <span class="number">0xfff0</span></span><br><span class="line"><span class="built_in">CS</span> selector <span class="number">0xf000</span></span><br><span class="line"><span class="built_in">CS</span> base     <span class="number">0xffff0000</span></span><br></pre></td></tr></table></figure></p>
<p>3.CPU此时工作在实模式，采用分段管理内存，无分页， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate）。</p>
<p>4.根据复位后的cs:ip此时逻辑地址为：<code>0xffff0000:0xfff0</code>即4GB-16字节。指向第一条代码：<a href="https://stackoverflow.com/questions/22190042/intel-reset-vector" target="_blank" rel="noopener">reset vector</a>。此时这个地址是被映射到ROM中的。</p>
<p>5.reset vector包括一个FAR jump跳到BIOS的入口。</p>
<p>6.BIOS做初始化与检查。然后寻找引导程序。对于硬盘，找MBR</p>
<p>7.BIOS将控制权交给引导程序。一般采用GRUB2引导</p>
<p>8.引导完成，调用<code>grub_main</code>初始化，置于normal模式。</p>
<p>9.<code>grub_normal_execute</code>显示可用操作系统<img src="https://s1.ax1x.com/2020/07/16/UDKcDA.png" alt=""></p>
<p>10.操作系统选定，<code>grub_menu_execute_entry</code>开始执行，它将调用 GRUB 的 boot 命令，来引导被选中的操作系统。</p>
<p>11.bootloader完毕，交还控制权给kernel，kernel代码从以下开始执行</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1000</span> + X + sizeof(KernelBootSector) + <span class="number">1</span> <span class="comment">//X 是 kernel bootsector 被引导入内存的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="进入内核前的准备"><a href="#进入内核前的准备" class="headerlink" title="进入内核前的准备"></a>进入内核前的准备</h2><p>1.内核设置的起点是<code>arch/x86/boot/header.S</code>中的<code>_start</code>函数开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter <span class="keyword">this</span> as bytes, <span class="keyword">or</span> the assembler</span><br><span class="line">		<span class="meta"># tries to generate a 3-byte jump here, which causes</span></span><br><span class="line">		<span class="meta"># everything <span class="meta-keyword">else</span> to push off to the wrong offset.</span></span><br><span class="line">		.<span class="keyword">byte</span>	<span class="number">0xeb</span>		<span class="meta"># short (2-byte) jump</span></span><br><span class="line">		.<span class="keyword">byte</span>	start_of_setup<span class="number">-1f</span></span><br></pre></td></tr></table></figure>

<p>2.<code>_start</code>函数做一个短跳转到<code>start_of_setup - 1f</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">	.section <span class="string">".entrytext"</span>, <span class="string">"ax"</span></span><br><span class="line">start_of_setup:</span><br><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx</span><br><span class="line">	je	<span class="number">2f</span>		# -&gt; assume %sp is reasonably <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">	# Invalid %ss, make up a <span class="keyword">new</span> <span class="built_in">stack</span></span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	<span class="number">1f</span></span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line"><span class="number">1</span>:	addw	$STACK_SIZE, %dx</span><br><span class="line">	jnc	<span class="number">2f</span></span><br><span class="line">	xorw	%dx, %dx	# Prevent wraparound</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:	# Now %dx should <span class="built_in">point</span> to the <span class="built_in">end</span> of our <span class="built_in">stack</span> space</span><br><span class="line">	andw	$~<span class="number">3</span>, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	<span class="number">3f</span></span><br><span class="line">	movw	$<span class="number">0xfffc</span>, %dx	# Make sure we<span class="number">'</span>re <span class="keyword">not</span> zero</span><br><span class="line"><span class="number">3</span>:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working <span class="built_in">stack</span></span><br><span class="line"></span><br><span class="line"># We will have entered with %cs = %ds+<span class="number">0x20</span>, normalize %cs so</span><br><span class="line"># it is on par with the other segments.</span><br><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$<span class="number">6f</span></span><br><span class="line">	lretw</span><br><span class="line"><span class="number">6</span>:</span><br><span class="line"></span><br><span class="line"># Check signature at <span class="built_in">end</span> of <span class="built_in">setup</span></span><br><span class="line">	cmpl	$<span class="number">0x5a5aaa55</span>, setup_sig</span><br><span class="line">	jne	setup_bad</span><br><span class="line"></span><br><span class="line"># Zero the bss</span><br><span class="line">	movw	$__bss_start, %di</span><br><span class="line">	movw	$_end+<span class="number">3</span>, %cx</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	subw	%di, %cx</span><br><span class="line">	shrw	$<span class="number">2</span>, %cx</span><br><span class="line">	rep; stosl</span><br><span class="line"></span><br><span class="line"># <span class="function">Jump to C <span class="title">code</span> <span class="params">(should <span class="keyword">not</span> <span class="keyword">return</span>)</span></span></span><br><span class="line"><span class="function">	calll	main</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先将设置段寄存器（通过%dx）</li>
<li>然后设置堆栈</li>
<li>检查签名</li>
<li>设置bss</li>
<li>跳到main函数执行（c语言）<code>arch/x86/boot/main.c</code></li>
</ul>
<h2 id="进入内核"><a href="#进入内核" class="headerlink" title="进入内核"></a>进入内核</h2><h3 id="进入保护模式之前的准备"><a href="#进入保护模式之前的准备" class="headerlink" title="进入保护模式之前的准备"></a>进入保护模式之前的准备</h3><p>1.main.c首先调用<code>copy_boot_params();</code>拷贝启动参数到<code>boot_params.hdr</code>通过调用：<code>memcpy(&amp;boot_params.hdr, &amp;hdr, sizeof(hdr));</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl	hdr</span><br><span class="line">hdr:</span><br><span class="line">setup_sects:	.<span class="keyword">byte</span> <span class="number">0</span>			<span class="comment">/* Filled in by build.c */</span></span><br><span class="line">root_flags:	.<span class="keyword">word</span> ROOT_RDONLY</span><br><span class="line">syssize:	.<span class="keyword">long</span> <span class="number">0</span>			<span class="comment">/* Filled in by build.c */</span></span><br><span class="line">ram_size:	.<span class="keyword">word</span> <span class="number">0</span>			<span class="comment">/* Obsolete */</span></span><br><span class="line">vid_mode:	.<span class="keyword">word</span> SVGA_MODE</span><br><span class="line">root_dev:	.<span class="keyword">word</span> <span class="number">0</span>			<span class="comment">/* Filled in by build.c */</span></span><br><span class="line">boot_flag:	.<span class="keyword">word</span> <span class="number">0xAA55</span></span><br></pre></td></tr></table></figure>

<p>2.接下来进行控制台初始化<code>console_init();</code>使用0x10中断输出一些字符。</p>
<p>3.接下来做堆初始化<code>init_heap();</code>计算堆的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_heap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *stack_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">		<span class="keyword">asm</span>(<span class="string">"leal %P1(%%esp),%0"</span></span><br><span class="line">		    : <span class="string">"=r"</span> (stack_end) : <span class="string">"i"</span> (-STACK_SIZE));</span><br><span class="line"></span><br><span class="line">		heap_end = (<span class="keyword">char</span> *)</span><br><span class="line">			((<span class="keyword">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br><span class="line">		<span class="keyword">if</span> (heap_end &gt; stack_end)</span><br><span class="line">			heap_end = stack_end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Boot protocol 2.00 only, no heap available */</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"WARNING: Ancient bootloader, some functionality "</span></span><br><span class="line">		     <span class="string">"may be limited!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.然后调用<code>validate_cpu()</code>检查cpu类型是否与kernel相合适，是否可以正常启动。当不满足cpu等级或一些特定的feature时不许启动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">validate_cpu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 *err_flags;</span><br><span class="line">	<span class="keyword">int</span> cpu_level, req_level;</span><br><span class="line"></span><br><span class="line">	check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"This kernel requires an %s CPU, "</span>,</span><br><span class="line">		       cpu_name(req_level));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"but only detected an %s CPU.\n"</span>,</span><br><span class="line">		       cpu_name(cpu_level));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err_flags) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"This kernel requires the following features "</span></span><br><span class="line">		     <span class="string">"not present on the CPU:\n"</span>);</span><br><span class="line">		show_cap_strs(err_flags);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_knl_erratum()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是64bits的设置level为64以及long mode<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test_bit(X86_FEATURE_LM, cpu.flags))</span><br><span class="line">	cpu.level = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FEATURE_LM			( 1*32+29) <span class="comment">/* Long Mode (x86-64, 64-bit support) */</span></span></span><br></pre></td></tr></table></figure></li>
<li>If this is an AMD and we’re only missing SSE+SSE2, try to turn them on</li>
<li>If this is a VIA C3, we might have to enable CX8 explicitly </li>
</ul>
<p>5.告诉BIOS我们的cpu模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br></pre></td></tr></table></figure>

<p>6.内存布局探测：<code>detect_memory();</code>调用<code>detect_memory_e820();</code>循环探测，最终信息存在<code>e820_entries;</code><img src="https://s1.ax1x.com/2020/07/16/UDBZ7V.png" alt=""></p>
<p>7.键盘初始化：<code>keyboard_init();</code>用0x16中断获取键盘状态。</p>
<p>8.一系列系统参数查询：机器型号，BIOS版本，高级电源管理等</p>
<p>9.<code>set_video();</code>设置显示模式。</p>
<p>10.<code>go_to_protected_mode();</code>进入保护模式之前最后的准备（所有的x86 CPU都是在实模式下引导，来确保传统操作系统的兼容性。为了使用保护模式的特性，要由程序主动地切换到保护模式。在现今的电脑上，这种切换通常是操作系统在引导时候完成的第一件任务。当CPU在保护模式下运行时，可以使用虚拟86模式来运行为实模式设计的代码。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_to_protected_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Hook before leaving real mode, also disables interrupts */</span></span><br><span class="line">	realmode_switch_hook();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable the A20 gate */</span></span><br><span class="line">	<span class="keyword">if</span> (enable_a20()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"A20 gate not responding, unable to boot...\n"</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset coprocessor (IGNNE#) */</span></span><br><span class="line">	reset_coprocessor();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Mask all interrupts in the PIC */</span></span><br><span class="line">	mask_all_interrupts();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Actual transition to protected mode... */</span></span><br><span class="line">	setup_idt();</span><br><span class="line">	setup_gdt();</span><br><span class="line">	protected_mode_jump(boot_params.hdr.code32_start,</span><br><span class="line">			    (u32)&amp;boot_params + (ds() &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>realmode_switch_hook();</code>如果发现real_mode的hook函数，那么调用他。else的话清楚中断标志IF（禁止外部中断），然后禁止<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener">NMI中断</a>（非可屏蔽中断比如时钟中断）。最后调用<code>io_delay</code>等待操作完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realmode_switch_hook</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.realmode_swtch) &#123;</span><br><span class="line">		<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lcallw *%0"</span></span></span></span><br><span class="line"><span class="function"><span class="params">			     : : <span class="string">"m"</span> (boot_params.hdr.realmode_swtch)</span></span></span><br><span class="line"><span class="function"><span class="params">			     : <span class="string">"eax"</span>, <span class="string">"ebx"</span>, <span class="string">"ecx"</span>, <span class="string">"edx"</span>)</span></span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">"cli"</span>);</span><br><span class="line">		outb(<span class="number">0x80</span>, <span class="number">0x70</span>); <span class="comment">/* Disable NMI */</span></span><br><span class="line">		io_delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是<code>enable_a20()</code>激活<a href="https://zh.wikipedia.org/wiki/A20%E6%80%BB%E7%BA%BF" target="_blank" rel="noopener">A20总线</a>，之后使用<code>reset_coprocessor();</code>与<code>mask_all_interrupts();</code><em>复位数字协处理器、屏蔽中断控制器的所有中断、和主中断控制器上除IRQ2以外的所有中断（IRQ2是主中断控制器上的级联中断，所有从中断控制器的中断将通过这个级联中断报告给 CPU ）</em><br><strong>至此，所有进入保护模式之前的准备工作已经完成，给出整体的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* First, copy the boot header into the "zeropage" */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the early-boot console */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">"debug"</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"early console in setup code\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End of heap check */</span></span><br><span class="line">	init_heap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have all the proper CPU support */</span></span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Unable to boot - please use a kernel appropriate "</span></span><br><span class="line">		     <span class="string">"for your CPU.\n"</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detect memory layout */</span></span><br><span class="line">	detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set keyboard repeat rate (why?) and query the lock flags */</span></span><br><span class="line">	keyboard_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query Intel SpeedStep (IST) information */</span></span><br><span class="line">	query_ist();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query APM information */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query EDD information */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the video mode */</span></span><br><span class="line">	set_video();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the last things and invoke protected mode */</span></span><br><span class="line">	go_to_protected_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Actual transition to protected mode... */</span></span><br><span class="line">	setup_idt();</span><br><span class="line">	setup_gdt();</span><br><span class="line">	protected_mode_jump(boot_params.hdr.code32_start,</span><br><span class="line">			    (u32)&amp;boot_params + (ds() &lt;&lt; <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>1.首先是<code>setup_idt();</code><a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/1907776?fr=aladdin" target="_blank" rel="noopener">用来设置中断描述符表(IDT)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the IDT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_idt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr</span> <span class="title">null_idt</span> = &#123;</span><span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lidtl %0"</span> : : <span class="string">"m"</span> (null_idt))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lidtl将为空的null_idt载入寄存器IDT</p>
<p>2.接下来<code>setup_gdt();</code>来设置全局描述符表即GDT表,其中，定义了<code>boot_gdt[]</code>数组，这个数组中的内容就是我们要传给GDTR的段描述符的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_gdt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> u64 boot_gdt[] __attribute__((aligned(<span class="number">16</span>))) = &#123;</span><br><span class="line">		<span class="comment">/* CS: code, read/execute, 4 GB, base 0 */</span></span><br><span class="line">		[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(<span class="number">0xc09b</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">		<span class="comment">/* DS: data, read/write, 4 GB, base 0 */</span></span><br><span class="line">		[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(<span class="number">0xc093</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">		<span class="comment">/* TSS: 32-bit tss, 104 bytes, base 4096 */</span></span><br><span class="line">		<span class="comment">/* We only have a TSS here to keep Intel VT happy;</span></span><br><span class="line"><span class="comment">		   we don't actually use it for anything. */</span></span><br><span class="line">		[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(<span class="number">0x0089</span>, <span class="number">4096</span>, <span class="number">103</span>),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* Xen HVM incorrectly stores a pointer to the gdt_ptr, instead</span></span><br><span class="line"><span class="comment">	   of the gdt_ptr contents.  Thus, make it static so it will</span></span><br><span class="line"><span class="comment">	   stay in memory, at least long enough that we switch to the</span></span><br><span class="line"><span class="comment">	   proper kernel GDT. */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr</span> <span class="title">gdt</span>;</span></span><br><span class="line"></span><br><span class="line">	gdt.len = <span class="keyword">sizeof</span>(boot_gdt)<span class="number">-1</span>;</span><br><span class="line">	gdt.ptr = (u32)&amp;boot_gdt + (ds() &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lgdtl %0"</span> : : <span class="string">"m"</span> (gdt))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中GDT_ENTRY是一个宏定义,传入三个参数（标志，基地址，段长度）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY(flags, base, limit)			\</span></span><br><span class="line">	((((base)  &amp; _AC(<span class="number">0xff000000</span>,ULL)) &lt;&lt; (<span class="number">56</span><span class="number">-24</span>)) |	\</span><br><span class="line">	 (((flags) &amp; _AC(<span class="number">0x0000f0ff</span>,ULL)) &lt;&lt; <span class="number">40</span>) |	\</span><br><span class="line">	 (((limit) &amp; _AC(<span class="number">0x000f0000</span>,ULL)) &lt;&lt; (<span class="number">48</span><span class="number">-16</span>)) |	\</span><br><span class="line">	 (((base)  &amp; _AC(<span class="number">0x00ffffff</span>,ULL)) &lt;&lt; <span class="number">16</span>) |	\</span><br><span class="line">	 (((limit) &amp; _AC(<span class="number">0x0000ffff</span>,ULL))))</span><br></pre></td></tr></table></figure>
<p>标志字段二进制展开后每一位都有自己的含义。之后获取gdt长度，以及指针，最后载入GDTR寄存器。</p>
<p>3.最后调用<code>protected_mode_jump(boot_params.hdr.code32_start, (u32)&amp;boot_params + (ds() &lt;&lt; 4));</code>完成从实模式到保护模式的跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pmjump.S */</span></span><br><span class="line"><span class="keyword">void</span> __attribute__((noreturn))</span><br><span class="line">	protected_mode_jump(u32 entrypoint, u32 bootparams);</span><br></pre></td></tr></table></figure>
<p>接受两个参数：保护模式进入地址，bootparams结构的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL(protected_mode_jump)</span><br><span class="line">	movl	%edx, %esi		<span class="meta"># bootparams地址放入esi</span></span><br><span class="line"></span><br><span class="line">	xorl	%ebx, %ebx</span><br><span class="line">	movw	%cs, %bx		<span class="meta"># cs放入bx</span></span><br><span class="line">	shll	$<span class="number">4</span>, %ebx</span><br><span class="line">	addl	%ebx, <span class="number">2f</span></span><br><span class="line">	jmp	<span class="number">1f</span>			# Short jump to serialize on <span class="number">386</span>/<span class="number">486</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">	movw	$__BOOT_DS, %cx</span><br><span class="line">	movw	$__BOOT_TSS, %di</span><br><span class="line"></span><br><span class="line">	movl	%cr0, %edx		#</span><br><span class="line">	orb	$X86_CR0_PE, %dl	# 设置 CR0 寄存器相应的位使 CPU 进入保护模式：</span><br><span class="line">	movl	%edx, %cr0</span><br><span class="line"></span><br><span class="line">	# Transition to <span class="number">32</span>-<span class="built_in">bit</span> mode</span><br><span class="line">	.<span class="keyword">byte</span>	<span class="number">0x66</span>, <span class="number">0xea</span>		<span class="meta"># ljmpl opcode</span></span><br><span class="line"><span class="number">2</span>:	.<span class="keyword">long</span>	in_pm32			<span class="meta"># offset</span></span><br><span class="line">	.<span class="keyword">word</span>	__BOOT_CS		<span class="meta"># segment</span></span><br><span class="line">	# 执行长跳转到代码段</span><br><span class="line">ENDPROC(protected_mode_jump)</span><br></pre></td></tr></table></figure>
<p><strong>跳转之后我们就在保护模式下执行以下代码了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	.code32</span><br><span class="line">	.section <span class="string">".text32"</span>,<span class="string">"ax"</span></span><br><span class="line">GLOBAL(in_pm32)</span><br><span class="line">	# 进入<span class="number">32</span>位保护模式首先重置段寄存器</span><br><span class="line">	movl	%ecx, %ds</span><br><span class="line">	movl	%ecx, %es</span><br><span class="line">	movl	%ecx, %fs</span><br><span class="line">	movl	%ecx, %gs</span><br><span class="line">	movl	%ecx, %ss</span><br><span class="line">	# The <span class="number">32</span>-<span class="built_in">bit</span> code sets up its own <span class="built_in">stack</span>, but <span class="keyword">this</span> way we <span class="keyword">do</span> have</span><br><span class="line">	<span class="meta"># a valid stack <span class="meta-keyword">if</span> some debugging hack wants to use it.</span></span><br><span class="line">	addl	%ebx, %esp</span><br><span class="line"></span><br><span class="line">	# Set up TR to make Intel VT happy</span><br><span class="line">	ltr	%di</span><br><span class="line"></span><br><span class="line">	# 清空通用寄存器</span><br><span class="line">	# <span class="number">32</span>-<span class="built_in">bit</span> boot protocol</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	xorl	%ebx, %ebx</span><br><span class="line">	xorl	%ebp, %ebp</span><br><span class="line">	xorl	%edi, %edi</span><br><span class="line"></span><br><span class="line">	# Set up LDTR to make Intel VT happy</span><br><span class="line">	lldt	%cx</span><br><span class="line"></span><br><span class="line">	jmpl	*%eax			# Jump to the <span class="number">32</span>-<span class="built_in">bit</span> entrypoint</span><br><span class="line">ENDPROC(in_pm32)</span><br></pre></td></tr></table></figure>

<h3 id="从32位保护模式向64位长模式切换"><a href="#从32位保护模式向64位长模式切换" class="headerlink" title="从32位保护模式向64位长模式切换"></a>从32位保护模式向64位长模式切换</h3><p>1.<code>jmpl    *%eax            # Jump to the 32-bit entrypoint</code>时eax存储的是32位的入口点。</p>
<p>2.到达32位入口点，我们可以看到此时的目录：<code>arch/x86/boot/compressed/head_64.S</code>其中的compressed，因为bzimage 是由 vmlinux + 头文件 + 内核启动代码 被 gzip 压缩之后获得的。之前的属于内核启动代码。而head_64.S做内核解压前的准备。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	__HEAD</span><br><span class="line">	.code32</span><br><span class="line">ENTRY(startup_32)</span><br><span class="line">...</span><br><span class="line">ENDPROC(startup_32)</span><br></pre></td></tr></table></figure>
<p>其中__HEAD代表<code>#define __HEAD        .section    &quot;.head.text&quot;,&quot;ax&quot;</code>也就是说这个段是可执行的。</p>
<p>3.首先调用cld清空DF <a href="https://blog.csdn.net/GetNextWindow/article/details/24901461" target="_blank" rel="noopener">DF与串操作</a></p>
<p>4.通过<code>KEEP_SEGMENTS</code>标记来给段寄存器做正确的赋值。</p>
<p>5.计算我们代码和编译运行之间的位置偏差。通过：定义一个标签并且跳转到它，然后把栈顶抛出到一个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	leal	(BP_scratch+<span class="number">4</span>)(%esi), %esp</span><br><span class="line">	call	<span class="number">1f</span></span><br><span class="line"><span class="number">1</span>:	popl	%ebp</span><br><span class="line">	subl	$<span class="number">1b</span>, %ebp</span><br></pre></td></tr></table></figure>
<p>esi指向<code>bootparams</code>结构体，把结构体中scratch+4的地址放进esp制造出一个4字节临时栈。然后通过call 1f。此时1f标签的地址在栈顶，再把他pop到ebp然后ebp-1b就得到了<code>startup_32</code>的加载地址。</p>
<p>6.先找到<code>boot_stack_end</code>的实际地址，然后通过<code>call    verify_cpu</code>之后test eax中的返回值，验证cpu是否支持长模式和SSE。如果不支持，就hlt掉。</p>
<p>7.计算<strong>内核解压缩地址</strong>，此时ebp中的是<code>startup_32</code>的实际物理地址，当CONFIG_RELOCATABLE打开时，我们将ebp放在ebx中，然后做对齐（2M）然后与$LOAD_PHYSICAL_ADDR（对齐后内核加载位置的物理地址）比较，最后给<code>startup_32</code>加上偏移获得解压缩地址。结束后，ebp包含了加载时的地址，ebx包含了内核解压缩的目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">	movl	%ebp, %ebx</span><br><span class="line">	movl	BP_kernel_alignment(%esi), %eax</span><br><span class="line">	decl	%eax</span><br><span class="line">	addl	%eax, %ebx</span><br><span class="line">	notl	%eax</span><br><span class="line">	andl	%eax, %ebx</span><br><span class="line">	cmpl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line">	jge	<span class="number">1f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	movl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Target address to relocate to for decompression */</span></span><br><span class="line">	addl	$z_extract_offset, %ebx</span><br></pre></td></tr></table></figure>
<p>8.更新全局描述符表。全局描述符表 保存在 48位 GDTR-全局描述符表寄存器 中，由两个部分组成：</p>
<ul>
<li>GDT大小（16位）</li>
<li>GDT基地址（32位）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load new GDT with the 64bit segments using 32bit descriptor */</span></span><br><span class="line">leal	gdt(%ebp), %eax</span><br><span class="line">movl	%eax, gdt+<span class="number">2</span>(%ebp)</span><br><span class="line"><span class="function">lgdt	<span class="title">gdt</span><span class="params">(%ebp)</span></span></span><br></pre></td></tr></table></figure>
gdt偏移量整体结构如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	.data						<span class="comment">/*	位于data段 */</span></span><br><span class="line">gdt:</span><br><span class="line">	.<span class="keyword">word</span>	gdt_end - gdt		<span class="comment">/* gdt整体长度 */</span></span><br><span class="line">	.<span class="keyword">long</span>	gdt					<span class="comment">/*	gdt基地址 */</span></span><br><span class="line">	.<span class="keyword">word</span>	<span class="number">0</span>					</span><br><span class="line">	.quad	<span class="number">0x0000000000000000</span>	<span class="comment">/* NULL descriptor */</span></span><br><span class="line">	.quad	<span class="number">0x00af9a000000ffff</span>	<span class="comment">/* __KERNEL_CS */</span></span><br><span class="line">	.quad	<span class="number">0x00cf92000000ffff</span>	<span class="comment">/* __KERNEL_DS */</span></span><br><span class="line">	.quad	<span class="number">0x0080890000000000</span>	<span class="comment">/* TS descriptor */</span></span><br><span class="line">	.quad   <span class="number">0x0000000000000000</span>	<span class="comment">/* TS continued */</span></span><br><span class="line">gdt_end:</span><br></pre></td></tr></table></figure></li>
</ul>
<p>9.打开<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95/6285579?fromtitle=PAE%E6%A8%A1%E5%BC%8F&fromid=2726789&fr=aladdin" target="_blank" rel="noopener">PAE模式</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enable PAE mode */</span></span><br><span class="line">movl	%cr4, %eax</span><br><span class="line">orl	$X86_CR4_PAE, %eax</span><br><span class="line">movl	%eax, %cr4</span><br></pre></td></tr></table></figure>
<p>10.<strong>初期页表初始化，建立初期的4G启动页表</strong>。linux内核使用4级页表，一般建立六个页表，每张表4k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize Page tables to 0 */</span></span><br><span class="line">leal	pgtable(%ebx), %edi</span><br><span class="line">xorl	%eax, %eax</span><br><span class="line">movl	$((<span class="number">4096</span>*<span class="number">6</span>)/<span class="number">4</span>), %ecx</span><br><span class="line">rep	stosl</span><br></pre></td></tr></table></figure>
<p>其中pgtable定义如下，大小24k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	.section <span class="string">".pgtable"</span>,<span class="string">"a"</span>,@nobits</span><br><span class="line">	.balign <span class="number">4096</span></span><br><span class="line">pgtable:</span><br><span class="line">	.<span class="built_in">fill</span> <span class="number">6</span>*<span class="number">4096</span>, <span class="number">1</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>开始构建4级页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Build Level 4 */</span></span><br><span class="line">leal	pgtable + <span class="number">0</span>(%ebx), %edi</span><br><span class="line">leal	<span class="number">0x1007</span> (%edi), %eax	</span><br><span class="line">movl	%eax, <span class="number">0</span>(%edi)</span><br></pre></td></tr></table></figure>
<p>其中0x1007是四级页表的大小4096+7（页表项标记<code>PRESENT+RW+USER</code>）最后我们把第一个PDP（页目录指针）项地址写入PML4</p>
<p>11.在PDP表（页目录指针表、三级页表）建立4个2级页表（Page Directory）他们都带有<code>PRESENT+RW+USE 标记</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Build Level 3 */</span></span><br><span class="line">	leal	pgtable + <span class="number">0x1000</span>(%ebx), %edi</span><br><span class="line">	leal	<span class="number">0x1007</span>(%edi), %eax	<span class="comment">/* 把第一个 2 级页目录指针表的首项的地址放到 eax 寄存器 */</span></span><br><span class="line">	movl	$<span class="number">4</span>, %ecx</span><br><span class="line"><span class="number">1</span>:	movl	%eax, <span class="number">0x00</span>(%edi)</span><br><span class="line">	addl	$<span class="number">0x00001000</span>, %eax</span><br><span class="line">	addl	$<span class="number">8</span>, %edi		   <span class="comment">/* 计算后面的几个页目录指针项的地址，每个占 8 字节 */</span></span><br><span class="line">	decl	%ecx</span><br><span class="line">	jnz	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>12.建立2048个2M页表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Build Level 2 */</span></span><br><span class="line">	leal	pgtable + <span class="number">0x2000</span>(%ebx), %edi</span><br><span class="line">	movl	$<span class="number">0x00000183</span>, %eax	<span class="comment">/* 标记位PRESENT + WRITE + MBZ */</span></span><br><span class="line">	movl	$<span class="number">2048</span>, %ecx</span><br><span class="line"><span class="number">1</span>:	movl	%eax, <span class="number">0</span>(%edi)</span><br><span class="line">	addl	$<span class="number">0x00200000</span>, %eax</span><br><span class="line">	addl	$<span class="number">8</span>, %edi</span><br><span class="line">	decl	%ecx</span><br><span class="line">	jnz	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>最终我们拥有了一个4G表，映射了4G大小的内存。</p>
<p>13.最后将PML4的地址放入cr3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enable the boot page tables */</span></span><br><span class="line">leal	pgtable(%ebx), %eax</span><br><span class="line">movl	%eax, %cr3</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/19/URbRUJ.png" alt=""><br>14.设置<a href="https://baike.baidu.com/item/MSR/23446599?fr=aladdin" target="_blank" rel="noopener">MSR</a>中的EFER.LME(Extended Feature Enable Register)标记为 0xC0000080<br>15.切换向长模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup for the jump to 64bit mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the jump is performend we will be in long mode but</span></span><br><span class="line"><span class="comment"> * in 32bit compatibility mode with EFER.LME = 1, CS.L = 0, CS.D = 1</span></span><br><span class="line"><span class="comment"> * (and in turn EFER.LMA = 1).	To jump into 64bit mode we use</span></span><br><span class="line"><span class="comment"> * the new gdt/idt that has __KERNEL_CS with CS.L = 1.</span></span><br><span class="line"><span class="comment"> * We place all of the values on our mini stack so lret can</span></span><br><span class="line"><span class="comment"> * used to perform that far jump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pushl	$__KERNEL_CS	<span class="comment">//内核代码段地址入栈</span></span><br><span class="line">leal	startup_64(%ebp), %eax	//startup_up64导入eax</span><br></pre></td></tr></table></figure>
<p>之后打开分页与保护模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushl	%eax	<span class="comment">//startup_64入栈</span></span><br><span class="line"><span class="comment">/* Enter paged protected Mode, activating Long Mode */</span></span><br><span class="line">movl	$(X86_CR0_PG | X86_CR0_PE), %eax <span class="comment">/* Enable Paging and Protected mode */</span></span><br><span class="line">movl	%eax, %cr0</span><br><span class="line"><span class="comment">/* Jump from 32bit compatibility mode into 64bit mode. */</span></span><br><span class="line">lret</span><br></pre></td></tr></table></figure>
<p>最后执行lret，因为startup_64已经入栈，这里就跳向了64位模式的起始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	.code64</span><br><span class="line">	.org <span class="number">0x200</span></span><br><span class="line">ENTRY(startup_64)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 64bit entry is 0x200 and it is ABI so immutable!</span></span><br><span class="line"><span class="comment">	 * We come here either from startup_32 or directly from a</span></span><br><span class="line"><span class="comment">	 * 64bit bootloader.</span></span><br><span class="line"><span class="comment">	 * If we come here from a bootloader, kernel(text+data+bss+brk),</span></span><br><span class="line"><span class="comment">	 * ramdisk, zero_page, command line could be above 4G.</span></span><br><span class="line"><span class="comment">	 * We depend on an identity mapped page table being provided</span></span><br><span class="line"><span class="comment">	 * that maps our entire kernel(text+data+bss+brk), zero page</span></span><br><span class="line"><span class="comment">	 * and command line.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EFI_STUB</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The entry point for the PE/COFF executable is efi_pe_entry, so</span></span><br><span class="line"><span class="comment">	 * only legacy boot loaders will execute this jmp.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	jmp	preferred_addr</span><br></pre></td></tr></table></figure>
<p><strong>至此正式从32位保护模式进入64位长模式</strong></p>
<h3 id="内核解压"><a href="#内核解压" class="headerlink" title="内核解压"></a>内核解压</h3><p>1.进入64位长模式后首先设置段寄存器的值，然后是计算内核编译时的位置和它被加载的位置的差（类似32位）<code>rbp</code>最后包含解压后内核的起始地址。<code>rbx</code>包含用于解压的重定位内核代码的地址。</p>
<p>2.设置栈指针与标志寄存器重置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up the stack */</span></span><br><span class="line">leaq	boot_stack_end(%rbx), %rsp</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Zero EFLAGS */</span></span><br><span class="line">pushq	$<span class="number">0</span></span><br><span class="line">popfq</span><br></pre></td></tr></table></figure>
<p>3.复制压缩的内核到buffer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the compressed kernel to the end of our buffer</span></span><br><span class="line"><span class="comment"> * where decompression in place becomes safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	pushq	%rsi	<span class="comment">//保存指向boot_params的指针</span></span><br><span class="line">	leaq	(_bss<span class="number">-8</span>)(%rip), %rsi</span><br><span class="line">	leaq	(_bss<span class="number">-8</span>)(%rbx), %rdi</span><br><span class="line">	movq	$_bss <span class="comment">/* - $startup_32 */</span>, %rcx</span><br><span class="line">	shrq	$<span class="number">3</span>, %rcx</span><br><span class="line">	<span class="built_in">std</span></span><br><span class="line">	rep	movsq</span><br><span class="line">	cld				<span class="comment">//清除DF</span></span><br><span class="line">	popq	%rsi</span><br></pre></td></tr></table></figure>
<p>压缩了的代码镜像存放在这份复制了的代码（从startup_32到当前的代码）和解压了的代码之间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Be careful parts of head_64.S assume startup_32 is at</span></span><br><span class="line"><span class="comment">	 * address 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	. = <span class="number">0</span>;</span><br><span class="line">	.head.<span class="built_in">text</span> : &#123;	<span class="comment">/*包含startup_32*/</span></span><br><span class="line">		_head = . ;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">		_ehead = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	.rodata..compressed : &#123;	<span class="comment">/*	包含了压缩了的内核镜像 */</span></span><br><span class="line">		*(.rodata..compressed)</span><br><span class="line">	&#125;</span><br><span class="line">	.<span class="built_in">text</span> :	&#123;</span><br><span class="line">		_text = .; 	<span class="comment">/* 解压代码 */</span></span><br><span class="line">		*(.<span class="built_in">text</span>)</span><br><span class="line">		*(.<span class="built_in">text</span>.*)</span><br><span class="line">		_etext = . ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最后跳转到.text解压</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jump to the relocated address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	leaq	relocated(%rbx), %rax</span><br><span class="line">	jmp	*%rax</span><br></pre></td></tr></table></figure>
<p>4.进入.text中首先清空bss节，然后调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> *<span class="title">decompress_kernel</span><span class="params">(<span class="keyword">void</span> *rmode, memptr heap,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">char</span> *input_data,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> input_len,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">char</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> output_len,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> run_size)</span></span></span><br></pre></td></tr></table></figure>
<p>进行内核的解压。</p>
<p>5.在解压函数中会初始化控制台，然后拿heap的位置。下一步调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* The memory hole needed for the kernel is the larger of either</span></span><br><span class="line"><span class="comment">	* the entire decompressed kernel plus relocation table, or the</span></span><br><span class="line"><span class="comment">	* entire decompressed kernel plus .bss and .brk sections.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">output = choose_kernel_location(input_data, input_len, output,</span><br><span class="line">				output_len &gt; run_size ? output_len</span><br><span class="line">								: run_size);</span><br></pre></td></tr></table></figure>

<p>6.<code>choose_kernel_location</code>分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">choose_kernel_location</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> input_size,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">char</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> output_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> choice = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)output;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">random</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIBERNATION</span></span><br><span class="line">	<span class="keyword">if</span> (!cmdline_find_option_bool(<span class="string">"kaslr"</span>)) &#123;</span><br><span class="line">		debug_putstr(<span class="string">"KASLR disabled by default...\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">"nokaslr"</span>)) &#123;</span><br><span class="line">		debug_putstr(<span class="string">"KASLR disabled by cmdline...\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Record the various known unsafe memory ranges. */</span></span><br><span class="line">	mem_avoid_init((<span class="keyword">unsigned</span> <span class="keyword">long</span>)input, input_size,</span><br><span class="line">		       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)output, output_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Walk e820 and find a random address. */</span></span><br><span class="line">	<span class="built_in">random</span> = find_random_addr(choice, output_size);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">random</span>) &#123;</span><br><span class="line">		debug_putstr(<span class="string">"KASLR could not find suitable E820 region...\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always enforce the minimum. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">random</span> &lt; choice)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	choice = <span class="built_in">random</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)choice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到调用了<code>cmdline_find_option_bool(&quot;kaslr&quot;)</code>来查找是否打开kaslr，之前做kernel pwn的时候直接用nokaslr关闭随机化原理就是这个。</li>
<li>通过调用<code>find_random_addr(choice, output_size);</code>查找一个随机地址。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_random_addr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> minimum,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure minimum is aligned. */</span></span><br><span class="line">	minimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Verify potential e820 positions, appending to slots list. */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; real_mode-&gt;e820_entries; i++) &#123;</span><br><span class="line">		process_e820_entry(&amp;real_mode-&gt;e820_map[i], minimum, <span class="built_in">size</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slots_fetch_random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>7.返回找到满足要求的随机地址。并且验证地址合法性。然后调用<code>decompress(input_data, input_len, NULL, NULL, output, NULL, error);</code>进行解压，其具体实现取决于选择什么算法。</p>
<p>8.最后调用的两个函数是：<code>parse_elf(output);</code>与<code>handle_relocations(output, output_len);</code>他们的作用是把解压后的内核移动到正确的位置。Linux内核就像是一个ELF可执行文件，我们进行原地解压，然后移动可加载段到正确的地址。</p>
<p>9.<code>parse_elf(output);</code>核心如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;ehdr, output, <span class="keyword">sizeof</span>(ehdr));</span><br><span class="line"><span class="keyword">if</span> (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||</span><br><span class="line">	ehdr.e_ident[EI_MAG1] != ELFMAG1 ||</span><br><span class="line">	ehdr.e_ident[EI_MAG2] != ELFMAG2 ||</span><br><span class="line">	ehdr.e_ident[EI_MAG3] != ELFMAG3) &#123;</span><br><span class="line">	error(<span class="string">"Kernel is not a valid ELF file"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取内核的头，检查ELF签名标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(phdrs, output + ehdr.e_phoff, <span class="keyword">sizeof</span>(*phdrs) * ehdr.e_phnum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ehdr.e_phnum; i++) &#123;</span><br><span class="line">		phdr = &amp;phdrs[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (phdr-&gt;p_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> PT_LOAD:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">			dest = output;</span><br><span class="line">			dest += (phdr-&gt;p_paddr - LOAD_PHYSICAL_ADDR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			dest = (<span class="keyword">void</span> *)(phdr-&gt;p_paddr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="built_in">memcpy</span>(dest,</span><br><span class="line">			       output + phdr-&gt;p_offset,</span><br><span class="line">			       phdr-&gt;p_filesz);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">/* Ignore other PT_* */</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(phdrs);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10.之后是&#96;&#96;&#96;handle_relocations(output, output_len);&#96;&#96;&#96;这个函数的具体实现依赖于&#96;&#96;&#96;CONFIG_X86_NEED_RELOCS&#96;&#96;&#96;，它主要是调整内核镜像的地址。</span><br><span class="line"></span><br><span class="line">11.最后返回output即内核的地址。然后:</span><br><span class="line"> &#96;&#96;&#96;c</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Jump to the decompressed kernel.</span><br><span class="line"> *&#x2F;</span><br><span class="line">	jmp	*%rax</span><br></pre></td></tr></table></figure>
<p>12.解压后的内核部分定义在：<code>arch/x86/kernel/head_64.S</code>注意与<code>arch/x86/boot/compressed/head_64.S</code>是不一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.<span class="built_in">text</span></span><br><span class="line">	__HEAD</span><br><span class="line">	.code64</span><br><span class="line">	.globl startup_64</span><br><span class="line">startup_64:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最终的<code>startup_64</code>就是<code>__START_KERNEL;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _START_KERNEL	(__START_KERNEL_map + __PHYSICAL_START)</span></span><br></pre></td></tr></table></figure>
<p>即（不考虑kaslr）：</p>
<ul>
<li>Linux 内核的默认物理基址：<em>0x1000000</em></li>
<li>Linux 内核的默认虚拟基址： <em>0xffffffff81000000</em></li>
</ul>
<p><strong>至此：我们进入了64位长模式，内核解压与重定位完成，正式启动，进入内核！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xinqiu.gitbooks.io/linux-inside-zh/content/" target="_blank" rel="noopener">Linux 内核揭密</a><br><a href="https://www.cnblogs.com/li-hao/p/4107964.html" target="_blank" rel="noopener">Linux下的lds链接脚本详解</a><br><a href="https://segmentfault.com/a/1190000007103522?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">ELF文件格式分析</a><br><a href="https://blog.csdn.net/u014022631/article/details/83419008" target="_blank" rel="noopener">e820与kernel物理内存映射</a><br><a href="https://cloud.tencent.com/developer/article/1421792" target="_blank" rel="noopener"> Linux四级页表(x64)</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Paxos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/">http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/08/14/di8hDO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/20/SROP-%E6%A0%88%E8%BF%81%E7%A7%BB-VN2020%E5%85%AC%E5%BC%80%E8%B5%9Bpwn/"><img class="prev_cover" src="https://s1.ax1x.com/2020/06/16/NPdUZ6.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">SROP+栈迁移_VN2020公开赛pwn</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/12/linux-%E5%86%85%E6%A0%B8pwn-0/"><img class="next_cover" src="https://s1.ax1x.com/2020/07/14/UNnv1P.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux Kernel pwn(0)——kernel ROP与ret2usr</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2020/07/16/Linux%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/';
  this.page.identifier = '2020/07/16/Linux内核基础/';
  this.page.title = 'Linux内核基础学习笔记';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://ScUpax0s.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script><script>function getDisqusCount() {
  var d = document, s = d.createElement('script');
  s.src = 'https://ScUpax0s.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
}

window.addEventListener('load', getDisqusCount, false);</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Paxos</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>